<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Circle Defense</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        :root {
            --left-panel-width: 190px; /* Tower Info */
            --right-panel-width: 70px;  /* Build Tower Panel */
            --bottom-bar-height: 30px; /* Approximate height for positioning other elements */
        }

        html, body {
             height: 100%; /* Ensure html takes full height too */
             margin: 0;
             padding: 0;
         }

        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #2d3748;
            color: #e2e8f0;
            display: flex;
            flex-direction: column;
            align-items: center; /* Center main-container horizontally */
            justify-content: flex-start; /* Align main-container to top */
            height: 100vh; /* Use full viewport height */
            padding-top: 0; /* <<< MODIFIED: Removed padding */
            padding-bottom: 0; /* <<< MODIFIED: Removed padding */
            overflow: hidden; /* <<< MODIFIED: Prevent all scrolling */
            overscroll-behavior-y: contain;
            position: relative;
        }

        .game-title-main {
            font-size: 1.6rem; margin-bottom: 8px; color: #fbd38d; text-shadow: 2px 2px #c05621; text-align: center;
             flex-shrink: 0; /* Prevent title from shrinking */
             padding-top: 10px; /* Add specific padding here if needed */
        }

        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            width: 100%;
            padding-left: 10px;
            padding-right: 10px;
            flex-grow: 1; /* <<< MODIFIED: Allow main container to fill vertical space */
            min-height: 0; /* <<< MODIFIED: Prevent flex overflow issues */
            overflow: hidden; /* Hide overflow within main container if needed */
        }

        /* MODIFIED: Changed game area wrapper layout AND REMOVED GAP */
        .game-area-wrapper {
             display: flex;
             /* removed flex-wrap */
             justify-content: center;
             align-items: stretch; /* Make children same height */
             width: 100%;
             /* removed position: relative */
             gap: 0; /* <<< MODIFIED: Set gap to 0 */
             flex-grow: 1; /* Allow wrapper to grow vertically */
             min-height: 0; /* Prevent flex overflow */
             overflow: hidden; /* Hide overflow */
             margin-bottom: 10px; /* Add space above bottom bar if needed */
         }

        .left-panel-container {
            display: flex; flex-direction: column; gap: 10px; width: 100%; max-width: var(--left-panel-width); flex-shrink: 0; order: 1;
        }
        @media (min-width: 768px) { .left-panel-container { width: var(--left-panel-width); } }

        .canvas-container {
            position: relative;
            flex-grow: 1; /* Allows it to grow horizontally */
            flex-shrink: 1;
            /* REMOVED max-width: 700px; */
            /* CONSIDER adjusting or removing aspect-ratio depending on desired scaling */
            /* aspect-ratio: 4 / 3; */ /* <<< MODIFIED: Commented out this line */
            order: 2;
            display: flex;
            justify-content: center;
            align-items: center;
            min-width: 280px;
            overflow: hidden;
             width: 100%; /* Make it take full width within the flex wrapper */
             /* height: auto; */ /* Let flexbox handle height */
             max-height: 100%; /* <<< ADDED: Ensure it doesn't overflow vertically */
        }
        canvas#gameCanvas {
            display: block;
            border: 3px solid #a0aec0;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            cursor: default;
            touch-action: none;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            /* Changed positioning and sizing for stretching */
            position: relative; /* Changed from absolute */
            width: 100%;
            height: 100%;
            object-fit: contain; /* Or 'fill' if you want it to stretch regardless of aspect ratio */
            max-width: 100%; /* Ensure canvas respects container width */
             max-height: 100%; /* Ensure canvas respects container height */
        }
        canvas.cursor-placement { cursor: cell; }
        canvas.cursor-pointer { cursor: pointer; }
        canvas.cursor-default { cursor: default; }
        canvas.cursor-invalid { cursor: not-allowed; }

        /* MODIFIED: Right panel positioning */
        .right-panel-container {
            /* removed position: absolute, right, top, z-index, transition, transform */
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: var(--right-panel-width);
            order: 3; /* Place after canvas */
            flex-shrink: 0; /* Prevent shrinking */
        }
        /* removed .right-panel-container.shrunk rule */

        .panel {
            background-color: #1a202c; padding: 10px; border-radius: 0px; /* <<< MODIFIED */ border: 2px solid #a0aec0; box-shadow: 0 0 8px rgba(0, 0, 0, 0.4); width: 100%; transition: background-color 0.3s ease; display: flex; flex-direction: column; height: 100%; /* Stretch vertically */
            min-height: 0; /* Prevent panel content overflow */
        }
        /* MODIFIED: Reverted styles previously specific to absolute positioning AND removed border-radius */
        .right-panel-container > .panel {
             background-color: #1a202c; /* Reverted from transparent */
             border-radius: 0px; /* <<< MODIFIED */
             border: 2px solid #a0aec0; /* Added border back */
             box-shadow: 0 0 8px rgba(0, 0, 0, 0.4); /* Added shadow back */
        }
        .panel-title { /* General panel title */
            font-size: 0.75rem; color: #cbd5e0; margin-bottom: 8px; text-align: center; width: 100%; border-bottom: 1px solid #4a5568; padding-bottom: 5px; flex-shrink: 0;
        }
        /* Specific style for right panel title */
        .right-panel-container .panel-title {
             font-size: 0.6rem; /* Even smaller size */
             padding-bottom: 4px; /* Adjust padding */
             margin-bottom: 6px; /* Adjust margin */
             text-align: center; /* Ensure centering */
         }

        #panel-resources {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding-bottom: 8px;
            margin-bottom: 8px;
            border-bottom: 1px solid #4a5568;
            flex-shrink: 0;
            user-select: none;
        }
        #panel-resources span {
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            line-height: 1;
        }
        #panel-resources .icon {
            font-family: sans-serif;
            font-size: 0.9rem;
            display: inline-block;
            min-width: 1.1em;
            text-align: center;
        }
        #lives-counter-display { color: #fc8181; }
        #gold-counter-display { color: #fefcbf; }

        #tower-selection-panel {
            flex-grow: 1;
            overflow-y: auto; /* Allow scrolling only within this panel if needed */
            /* Hide scrollbar */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none;  /* IE and Edge */
        }
        #tower-selection-panel::-webkit-scrollbar {
            display: none; /* WebKit */
        }
        #tower-selection-panel .panel-content {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            transition: all 0.3s ease;
            padding: 0 2px;
        }
        .tower-item { display: flex; flex-direction: column; align-items: center; padding: 5px; border: 2px solid #4a5568; border-radius: 6px; background-color: #2d3748; cursor: pointer; transition: all 0.2s ease; position: relative; user-select: none; min-height: 50px; width: 100%; box-sizing: border-box; }
        .tower-item:hover:not(.disabled) { background-color: #4a5568; border-color: #a0aec0; transform: scale(1.03); box-shadow: 0 0 6px rgba(251, 211, 141, 0.4); z-index: 5; }
        .tower-item:active:not(.disabled) { transform: scale(1.01); }
        .tower-item.selected-for-placement { border-color: #fbd38d; background-color: #4a5568; }
        .tower-item.disabled { cursor: not-allowed; opacity: 0.6; filter: grayscale(70%); }
        .tower-item.disabled:hover { background-color: #2d3748; border-color: #4a5568; transform: none; box-shadow: none; }
        .tower-preview-icon { width: 38px; height: 38px; margin-bottom: 2px; border: 1px solid #a0aec0; display: flex; align-items: center; justify-content: center; overflow: hidden; background-color: #4a5568; }
        .tower-preview-icon canvas, .tower-preview-icon img { display: block; width: 100%; height: 100%; object-fit: contain; image-rendering: pixelated; image-rendering: crisp-edges; background-color: transparent; border: none; box-shadow: none; }
        .tower-name { display: none !important; }
        .tower-cost { display: none !important; }

        #tower-info-panel {
            font-size: 10px; line-height: 1.4; flex-grow: 1; display: flex; flex-direction: column; gap: 6px; transition: all 0.3s ease; overflow-y: auto; /* Allow scrolling only within this panel if needed */
        }
        #info-content { margin-bottom: 0; flex-grow: 1; }
        #info-content p { margin-bottom: 3px; }
        #info-content span { color: #90cdf4; }
        #info-content .info-label { color: #a0aec0; font-weight: normal; margin-right: 4px;}
        #info-content .stat-value { font-family: 'VT323', monospace; font-size: 1.1rem; color: #e2e8f0; }
        #upgrade-options-container { margin-top: 8px; padding-top: 8px; border-top: 1px dashed #4a5568; display: flex; flex-direction: column; gap: 8px; flex-shrink: 0; overflow-y: auto; /* Allow scrolling for upgrades if they overflow */ max-height: 150px; /* Example max height */ }
        #upgrades-title { font-size: 11px; color: #fbd38d; text-align: center; margin-bottom: 5px; padding-bottom: 3px; border-bottom: 1px solid #63b3ed; }
        .upgrade-option { border: 2px solid #4a5568; border-radius: 6px; padding: 5px 6px; background-color: #2d3748; cursor: pointer; transition: border-color 0.2s, background-color 0.2s, transform 0.1s; flex-shrink: 0; /* Prevent options shrinking */ }
        .upgrade-option:hover:not(.disabled) { background-color: #4a5568; border-color: #a0aec0; transform: translateY(-1px);}
        .upgrade-option.disabled { cursor: not-allowed; opacity: 0.6; filter: grayscale(50%); border-color: #4a5568; }
        .upgrade-option.disabled:hover { background-color: #2d3748; transform: none;}
        .upgrade-option-title { font-size: 11px; color: #cbd5e0; display: flex; align-items: center; gap: 4px; margin-bottom: 2px; }
        .upgrade-option-desc {
            /* MODIFIED font-size from 9px */
            font-size: 8px; /* Smaller font size */
            color: #a0aec0;
            display: block;
            margin-bottom: 3px;
            /* MODIFIED line-height for tighter spacing */
            line-height: 1.2;
            word-break: break-word; /* Keeps long words from overflowing */
            min-height: 18px; /* Adjust if needed */
        }
        .upgrade-option-cost { font-size: 10px; color: #fbd38d; display: block; text-align: right; }
        .upgrade-option.disabled .upgrade-option-cost { color: #fc8181; }
        .upgrade-icon { width: 12px; height: 12px; display: inline-block; vertical-align: middle; margin-right: 4px; image-rendering: pixelated; }
        .l4-choice-wrapper { display: flex; gap: 6px; width: 100%; }
        .l4-choice-wrapper .upgrade-option { flex: 1; text-align: center; }
        .l4-choice-wrapper .upgrade-option-cost { text-align: center; margin-top: 3px; }
        .l4-choice-wrapper .upgrade-option-desc {
             min-height: 22px; /* Adjust if needed for L4 descriptions */
             /* Further reduced font-size for L4 choices */
             font-size: 7.5px;
         }
        #tower-info-buttons-container { margin-top: auto; padding-top: 8px; border-top: 1px dashed #4a5568; display: flex; flex-direction: column; gap: 5px; flex-shrink: 0; }
        #tower-info-buttons-container button, #tower-info-buttons-container select { width: 100%; font-size: 10px; padding: 5px 7px; margin: 0; }
        #tower-info-buttons-container select { background-color: #2d3748; border: 1px solid #a0aec0; color: #e2e8f0; padding: 3px; font-family: 'Press Start 2P', cursive; }

        /* REMOVED: #toggle-right-panel CSS rule */

        #game-controls { position: absolute; bottom: 5px; left: 5px; background-color: rgba(26, 32, 44, 0.8); padding: 4px 6px; border-radius: 6px; border: 1px solid #a0aec0; box-shadow: 0 0 6px rgba(0, 0, 0, 0.4); display: flex; flex-direction: row; gap: 6px; z-index: 50; width: auto; }
        #game-controls button { font-size: 0.8rem; line-height: 1; padding: 4px 8px; margin: 0; box-shadow: 0 1.5px #2f855a; display: flex; align-items: center; justify-content: center; min-width: 35px; }
        #game-controls button:active { box-shadow: 0 0.5px #2f855a; transform: translateY(1px); }
        #game-controls button.pause-btn.paused { background-color: #f6e05e; color: #1a202c; box-shadow: 0 1.5px #d69e2e; }
        #game-controls button.pause-btn.paused:hover { background-color: #ecc94b; }
        #game-controls button.pause-btn.paused:active { background-color: #d69e2e; box-shadow: 0 0.5px #d69e2e; transform: translateY(1px); }
        #start-wave-button.auto-start-on { background-color: #9f7aea; box-shadow: 0 1.5px #6b46c1; }
        #start-wave-button.auto-start-on:hover:not(:disabled) { background-color: #805ad5; }
        #start-wave-button.auto-start-on:active:not(:disabled) { background-color: #6b46c1; box-shadow: 0 0.5px #6b46c1; }
        #game-controls button:disabled { background-color: #a0aec0; box-shadow: 0 1.5px #718096; cursor: not-allowed; opacity: 0.7; }
        #game-controls button:disabled:hover { background-color: #a0aec0; }
        #game-controls button:disabled:active { transform: translateY(0); box-shadow: 0 1.5px #718096;}

        button { font-family: 'Press Start 2P', cursive; background-color: #48bb78; color: white; padding: 7px 12px; border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.3s ease, transform 0.1s ease, box-shadow 0.1s ease; box-shadow: 0 2px #2f855a; margin: 0; font-size: 0.75rem; white-space: nowrap; user-select: none; }
        button.sell-btn { background-color: #f56565; box-shadow: 0 2px #c53030; }
        button.sell-btn:hover:not(:disabled) { background-color: #e53e3e; }
        button.sell-btn:active:not(:disabled) { background-color: #c53030; box-shadow: 0 1px #c53030; transform: translateY(1px); }
        button.pause-btn.paused { background-color: #f6e05e; color: #1a202c; box-shadow: 0 2px #d69e2e; }
        button.pause-btn.paused:hover { background-color: #ecc94b; }
        button.pause-btn.paused:active { background-color: #d69e2e; box-shadow: 0 1px #d69e2e; transform: translateY(1px); }
        button:hover:not(:disabled) { background-color: #38a169; }
        button:active:not(:disabled) { background-color: #2f855a; box-shadow: 0 1px #2f855a; transform: translateY(1px); }
        button:disabled { background-color: #a0aec0; box-shadow: 0 2px #718096; cursor: not-allowed; opacity: 0.7; }
        button:disabled:hover { background-color: #a0aec0; }
        button:disabled:active { transform: translateY(0); box-shadow: 0 2px #718096;}

        #message-box {
            position: fixed;
            /* <<< MODIFIED: Position relative to bottom bar height */
            bottom: calc(var(--bottom-bar-height) + 10px); /* 10px above bottom bar */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.85);
            color: #fff; padding: 12px 18px; border-radius: 8px; z-index: 110; display: none; font-size: 13px; border: 2px solid #a0aec0; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5); text-align: center; max-width: 90%;
        }

        #range-preview-circle, .selected-tower-highlight, #placement-preview-tower { position: absolute; pointer-events: none; z-index: 30; box-sizing: border-box; }
        #range-preview-circle { border: 2px dashed rgba(255, 255, 255, 0.5); border-radius: 50%; background-color: rgba(255, 255, 255, 0.05); display: none; transform: translate(-50%, -50%); }
        #range-preview-circle.invalid-placement { border-color: rgba(255, 0, 0, 0.6); background-color: rgba(255, 0, 0, 0.1); }
        .selected-tower-highlight { border: 3px solid #fbd38d; border-radius: 4px; display: none; z-index: 29; transform: translate(-50%, -50%); }
        #placement-preview-tower { display: none; z-index: 31; opacity: 0.7; image-rendering: pixelated; image-rendering: crisp-edges; }
        #placement-preview-tower canvas { display: block; width: 100%; height: 100%; }

        #play-again-button {
            position: fixed;
            /* <<< MODIFIED: Position relative to bottom bar height */
            bottom: calc(var(--bottom-bar-height) + 15px); /* 15px above bottom bar */
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
        }
        .hit-effect-line { position: absolute; border-left: 1px solid white; background-color: white; height: 0.75px; transform-origin: 0 50%; pointer-events: none; z-index: 15; opacity: 0; transition: opacity 0.1s linear; }
        .hit-effect-line.gatling-tracer { height: 0.75px; background-color: #e2e8f0; transition: opacity 0.05s linear; }
        .tower-item[data-tooltip]::before { content: attr(data-tooltip); position: absolute; bottom: 105%; left: 50%; transform: translateX(-50%); background-color: #1a202c; color: #e2e8f0; padding: 4px 8px; border-radius: 4px; font-size: 9px; white-space: nowrap; opacity: 0; visibility: hidden; transition: opacity 0.2s ease, visibility 0.2s ease; pointer-events: none; z-index: 10; border: 1px solid #4a5568; font-family: 'VT323', monospace; }
        .tower-item[data-tooltip]:hover::before { opacity: 1; visibility: visible; }

        /* --- MODIFIED: Bottom Bar Styles --- */
        #bottom-bar {
            /* position: fixed; */ /* <<< MODIFIED: Removed fixed position */
            /* bottom: 0; */
            /* left: 0; */
            width: 100%;
            background-color: #1a202c; /* Match panel bg */
            color: #cbd5e0; /* Match panel title text */
            padding: 5px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 1px solid #4a5568; /* Match panel border-bottom */
            font-family: 'VT323', monospace; /* Use a monospace font */
            font-size: 0.9rem;
            /* z-index: 150; */ /* No longer needed without fixed position */
            box-sizing: border-box;
            flex-shrink: 0; /* Prevent bottom bar from shrinking */
            height: var(--bottom-bar-height); /* Give it an explicit height */
        }

        #game-title-bottom {
            /* Styles for the main title if needed */
        }

        #creator-credit {
            font-size: 0.8rem;
            color: #a0aec0; /* Slightly muted color */
        }
        /* --- END: Bottom Bar Styles --- */

        /* --- START: Landscape Adjustments --- */
        @media (orientation: landscape) and (max-height: 500px) { /* Target shorter landscape screens */
            :root {
                --left-panel-width: 120px; /* Reduced width for left panel */
                --right-panel-width: 60px; /* Reduced width for right panel */
                --bottom-bar-height: 25px; /* Slightly smaller bottom bar */
            }

            .game-title-main {
                font-size: 1.2rem; /* Smaller title */
                padding-top: 5px;
                margin-bottom: 5px;
            }

            .main-container {
                gap: 5px; /* Reduce gap */
            }

            #panel-resources span {
                font-size: 1.0rem; /* Slightly smaller resource font */
            }
            #panel-resources .icon {
                font-size: 0.8rem; /* Smaller icons */
            }

            #tower-selection-panel .tower-item {
                 min-height: 40px; /* Smaller tower buttons */
            }
            #tower-selection-panel .tower-preview-icon {
                width: 30px;
                height: 30px;
            }

            #tower-info-panel {
                font-size: 9px; /* Smaller info font */
            }
             #info-content .stat-value {
                 font-size: 1.0rem;
             }
            #upgrade-options-container {
                gap: 5px; /* Tighter upgrade spacing */
                max-height: 100px; /* Limit upgrade scroll height */
            }
            .upgrade-option {
                padding: 4px 5px;
            }
            .upgrade-option-title {
                font-size: 10px;
            }
            .upgrade-option-desc {
                 font-size: 7px; /* Even smaller descriptions */
                 line-height: 1.1;
                 min-height: 16px;
            }
            .upgrade-option-cost {
                font-size: 9px;
            }
             .l4-choice-wrapper .upgrade-option-desc {
                  font-size: 7px;
                  min-height: 20px;
              }
             #tower-info-buttons-container button,
             #tower-info-buttons-container select {
                font-size: 9px;
                padding: 4px 6px;
             }


            #game-controls {
                bottom: 3px;
                left: 3px;
                gap: 4px;
            }
             #game-controls button {
                font-size: 0.7rem;
                padding: 3px 6px;
                min-width: 30px;
             }

             #bottom-bar {
                padding: 3px 10px;
                font-size: 0.8rem;
             }
             #creator-credit {
                font-size: 0.7rem;
             }

             /* Optional: Hide panels completely on very narrow landscape screens */
             /*
             @media (orientation: landscape) and (max-width: 600px) {
                 .left-panel-container, .right-panel-container {
                     display: none;
                 }
                 .game-area-wrapper {
                     padding: 0;
                 }
             }
             */
        }
        /* --- END: Landscape Adjustments --- */

    </style>
</head>
<body>
    <main class="main-container">
         <h1 class="game-title-main">Circle Defense</h1> <div class="game-area-wrapper">

            <aside class="left-panel-container">
                <div id="tower-info-panel" class="panel">
                    <div class="panel-title">Tower Info</div>
                    <div id="info-content">Select a tower...</div>
                    <div id="upgrade-options-container"></div>
                    <div id="tower-info-buttons-container">
                        <button id="sell-tower-button" class="sell-btn" style="display: none;">Sell</button>
                        <select id="targeting-mode" style="display: none;" title="Set Tower Targeting Priority">
                            <option value="first">Target: First</option>
                            <option value="last">Target: Last</option>
                            <option value="strongest">Target: Strongest</option>
                            <option value="weakest">Target: Weakest</option>
                        </select>
                    </div>
                </div>
            </aside>

            <div class="canvas-container" id="canvas-container">
                <canvas id="gameCanvas"></canvas>
                <div id="range-preview-circle"></div>
                <div id="selected-tower-highlight" class="selected-tower-highlight"></div>
                <div id="placement-preview-tower">
                    <canvas id="placement-preview-canvas"></canvas>
                </div>
                <div id="game-controls">
                    <button id="start-wave-button" title="Start Next Wave / Toggle Auto-Start">▶</button>
                    <button id="pause-button" class="pause-btn" title="Pause/Resume">||</button>
                    <button id="speed-button" class="speed-btn" title="Toggle Game Speed">1x</button>
                </div>
            </div>

            <aside class="right-panel-container" id="right-panel">
                 <div id="tower-selection-panel" class="panel">
                     <div class="panel-title">Towers</div> <div id="panel-resources">
                         <span id="lives-counter-display" title="Lives"><span class="icon">❤️</span> <span>0</span></span>
                         <span id="gold-counter-display" title="Gold"><span class="icon">💰</span> <span>0</span></span>
                     </div>
                     <div class="panel-content"></div>
                 </div>
                </aside>

        </div>
         <button id="play-again-button" class="play-again-btn" style="display: none;">Play Again</button>
         <div id="message-box"></div>
    </main>

    <footer id="bottom-bar">
        <span id="game-title-bottom">Circle Defender</span>
        <span id="creator-credit">Created by Ryder Haddock</span>
    </footer>


<script>
    // --- DOM Elements ---
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const canvasContainer = document.getElementById("canvas-container");
    // REMOVED: waveCounterEl
    const livesCounterEl = document.querySelector("#lives-counter-display span:last-child");
    const goldCounterEl = document.querySelector("#gold-counter-display span:last-child");

    const startWaveButton = document.getElementById("start-wave-button");
    const pauseButton = document.getElementById("pause-button");
    const speedButton = document.getElementById("speed-button");
    const playAgainButton = document.getElementById("play-again-button");
    const towerSelectionPanelContent = document.querySelector("#tower-selection-panel .panel-content");
    const towerInfoPanel = document.getElementById("tower-info-panel");
    const towerInfoContent = document.getElementById("info-content");
    const upgradeOptionsContainer = document.getElementById("upgrade-options-container");
    const towerInfoButtonsContainer = document.getElementById("tower-info-buttons-container");
    const sellButton = document.getElementById("sell-tower-button");
    const targetingDropdown = document.getElementById("targeting-mode");
    const messageBox = document.getElementById("message-box");
    const rangePreviewCircle = document.getElementById("range-preview-circle");
    const selectionHighlight = document.getElementById("selected-tower-highlight");
    const placementPreviewDiv = document.getElementById("placement-preview-tower");
    const placementPreviewCanvas = document.getElementById("placement-preview-canvas");
    const placementPreviewCtx = placementPreviewCanvas.getContext("2d");
    const gameControlsContainer = document.getElementById("game-controls");
    const rightPanelContainer = document.getElementById("right-panel");
    // REMOVED: toggleRightPanelButton constant

    // --- Global Config / Game State / Classes / Functions ---
    const config = { MAP_WIDTH_TILES: 20, MAP_HEIGHT_TILES: 15, TILE_SIZE: 40, INITIAL_GOLD: 250, TOWER_UPGRADE_COST_MULTIPLIER: 1.7, TOWER_UPGRADE_STAT_MULTIPLIER: 2.1, INITIAL_LIVES: 20, ROUND_BONUS_FIXED: 100, ENEMY_HP_SCALE_FACTOR: 0, SELL_RETURN_RATIO: 0.75, ENEMY_SPAWN_INTERVAL_MS: 350, BG_COLOR: "#68d391", /* Changed background color back */ PATH_COLOR: "#808080", PATH_BORDER_COLOR: "#404040", FLOWER_COLORS: ["#FF69B4", "#FFD700", "#FFFFFF", "#9370DB"], GRASS_PATCH_COLOR: "#5aa57d", BACKGROUND_DETAIL_DENSITY: 0.06, AUTO_START_DELAY_MS: 1500 }; /* Default density */
    const HEALTH_SCALING_START_WAVE = 38;
    function setupCanvasSize() { canvas.width = config.MAP_WIDTH_TILES * config.TILE_SIZE; canvas.height = config.MAP_HEIGHT_TILES * config.TILE_SIZE; placementPreviewCanvas.width = config.TILE_SIZE; placementPreviewCanvas.height = config.TILE_SIZE; ctx.imageSmoothingEnabled = false; placementPreviewCtx.imageSmoothingEnabled = false; console.log(`Canvas Internal Resolution Set: ${canvas.width}x${canvas.height}`); }

    // MODIFIED: Removed wave counter update
    function setInitialUI() {
        if (goldCounterEl) goldCounterEl.textContent = config.INITIAL_GOLD;
        if (livesCounterEl) livesCounterEl.textContent = config.INITIAL_LIVES;
        // Wave number is now drawn on canvas, no initial setting here

        if (towerSelectionPanelContent) {
            towerSelectionPanelContent.querySelectorAll('.tower-item').forEach(item => {
                const typeId = item.dataset.towerType;
                if (typeId && TOWER_TYPES[typeId]) {
                    const baseCost = typeof TOWER_TYPES[typeId].baseCost === 'function' ? TOWER_TYPES[typeId].baseCost() : TOWER_TYPES[typeId].baseCost;
                    const canAfford = config.INITIAL_GOLD >= baseCost;
                    item.classList.toggle('disabled', !canAfford);
                }
            });
        }
    }

    // MODIFIED: Removed isBuildPanelOpen state
    const gameState = { gold: 0, lives: 0, wave: 0, enemies: [], towers: [], selectedTower: null, placingTowerType: null, isPaused: false, isRunning: false, waveInProgress: false, autoStartEnabled: false, gameSpeed: 1, spawnQueue: [], enemiesThisWave: 0, defeatedThisWave: 0, reachedEndThisWave: 0, towerDamageTracker: new Map(), totalTowerInvestment: new Map(), path: [], pathTiles: new Set(), occupiedTiles: new Set(), lastFrameTime: 0, deltaTime: 0, messageTimeout: null, gameLoopRequestId: null, nextSpawnTime: 0, mouseTile: { row: -1, col: -1 }, mousePos: { x: 0, y: 0 }, backgroundDetails: [], trees: [], rockPiles: [], pathDecorations: [], autoStartTimeoutId: null, nextBossIndex: 0, activeSatellites: new Map(), deadEnemyPositions: [], hitVisuals: [], particles: [], gameHasStarted: false };
    const loadedImages = {};
    const TOWER_TYPES = { CROSSBOW: { id: "CROSSBOW", name: "Crossbow", baseCost: 100, baseDamage: 28, baseRange: () => config.TILE_SIZE * 3.5, baseFireRate: 1.2, upgradeLevels: 4, description: "Fires bolts rapidly. Choose path at Lvl 4.", isMultipart: true, initialAngle: -Math.PI / 2, iconUsesImage: true, iconSrc: "photos/crossbowtop.level1.png", parts: { level1: { base: "photos/crossbowbottom.level1.png", barrel: "photos/crossbowtop.level1.png", barrelNaturalAngle: -Math.PI / 2, baseScale: 0.9, barrelScale: 1.1, barrelOffset: { x: 2, y: 0 } }, level2: { base: "photos/crossbowbottom.level2.png", barrel: "photos/crossbowtop.level2.png", barrelNaturalAngle: -Math.PI / 2, baseScale: 0.9, barrelScale: 1.1 }, level3: { base: "photos/crossbowbottom.level3.png", barrel: "photos/crossbowtop.level3.png", barrelNaturalAngle: -Math.PI / 2, baseScale: 0.9, barrelScale: 1.1 }, }, upgrades: { level2: { title: "Tighter String", description: "Increases damage and fire rate.", }, level3: { title: "Sharper Bolts", description: "Further increases damage.", }, }, level4_bigarrows: { name: "Heavy Crossbow", title: "Big Arrows", description: "Fires massive bolts that deal extreme damage, slower fire rate.", damageMultiplier: 6.0, rangeMultiplier: 1.15, fireRateMultiplier: 0.1, parts: { base: "photos/crossbowbottom.level4.png", barrel: "photos/crossbowtop.level4.png", barrelNaturalAngle: -Math.PI / 2, baseScale: 0.9, barrelScale: 1.1 } }, level4_icebow: { name: "Ice Bow", title: "Ice Bow", description: "Freezing bolts slow the target and nearby enemies.", damageMultiplier: 1.1, rangeMultiplier: 1.1, fireRateMultiplier: 1.4, appliesSlow: true, slowAmount: 0.55, slowDuration: 2200, splashSlow: true, splashSlowRadius: () => config.TILE_SIZE * 1.6, splashSlowMultiplier: 0.5, projectileColor: "#63B3ED", parts: { base: "photos/icebowbottom.png", barrel: "photos/icebowtop.png", barrelNaturalAngle: -Math.PI / 2, baseScale: 0.9, barrelScale: 1.1 } } }, CANNON: { id: "CANNON", name: "Cannon", baseCost: 150, baseDamage: 50, baseRange: () => config.TILE_SIZE * 3, baseFireRate: 1.0, upgradeLevels: 4, description: "Standard cannon. Choose path at Lvl 4.", isMultipart: true, initialAngle: Math.PI, iconUsesImage: true, iconSrc: "photos/cannontop.level1.png", parts: { level1: { base: "photos/cannonbottom.level1.png", barrel: "photos/cannontop.level1.png", barrelNaturalAngle: -Math.PI / 2, baseScale: 1.1, barrelScale: 1.0 }, level2: { base: "photos/cannonbottom.level2.png", barrel: "photos/cannontop.level2.png", barrelNaturalAngle: -Math.PI / 2, baseScale: 1.0, barrelScale: 0.85 }, level3: { base: "photos/cannonbottom.level3.png", barrel: "photos/cannontop.level3.png", barrelNaturalAngle: -Math.PI / 2, baseScale: 1.2, barrelScale: 1.0 }, }, upgrades: { level2: { title: "Increased Gunpowder", description: "Increases range and damage.", }, level3: { title: "Silver Barrel", description: "Increased damage.", }, }, level4_dragon: { name: "Dragon Cannon", title: "Dragon", description: "Breathes fire", /* <<< MODIFIED DESCRIPTION */ damageMultiplier: 0.25, /* <<< MODIFIED: Changed from 0.8 */ rangeMultiplier: 1.0, fireRateMultiplier: 1.0, isSplashDamage: true, splashRadius: () => config.TILE_SIZE * 2.0, maxSplashTargets: 6, parts: { base: "photos/dragonbottom.png", barrel: "photos/dragontop.png", barrelNaturalAngle: -Math.PI / 2, baseScale: 1.1, barrelScale: 1.5 } }, level4_double: { name: "2x", title: "2x", description: "2 cannons", /* <<< MODIFIED DESCRIPTION */ damageMultiplier: 1.0, rangeMultiplier: 1.0, fireRateMultiplier: 2.0, isSplashDamage: false, parts: { base: "photos/cannonbottom.level4.png", barrel: "photos/cannontop.level4.png", barrelNaturalAngle: -Math.PI / 2, baseScale: 1.0, barrelScale: 1.0 } } }, LASER: { id: "LASER", name: "Laser", baseCost: 300, baseDamage: 5, baseRange: () => config.TILE_SIZE * 3.5, baseFireRate: 1, upgradeLevels: 4, description: "Continuous damage beam. Can be overcharged at Lvl 4.", isBeam: true, projectileColor: "#00BFFF", projectileSize: 2, mapUsesImage: true, initialAngle: -Math.PI / 2, beamOriginOffset: { x: 0, y: -config.TILE_SIZE * 0.4 }, parts: { level1: { image: "photos/lazer.level1.png" }, level2: { image: "photos/lazer.level2.png" }, level3: { image: "photos/lazer.level3.png" }, }, iconUsesImage: true, iconSrc: "photos/lazer.level1.png", upgrades: { level2: { title: "Focus Crystal", description: "Increases damage.", }, level3: { title: "Wider Beam", description: "Increases damage slightly.", }, }, level4: { name: "Overcharged Laser", title: "Overcharge", description: "Melts targets with a significantly boosted energy beam.", damageMultiplier: 1.1, rangeMultiplier: 1.15, fireRateMultiplier: 1.0, parts: { image: "photos/lazer.level4.png" } } }, GATLING: { id: "GATLING", name: "Gatling Bunker", baseCost: 400, baseDamage: 20, baseRange: () => config.TILE_SIZE * 4, baseFireRate: 1.0, upgradeLevels: 4, description: "Stationary bunker firing rapidly. Can enter overdrive at Lvl 4.", iconUsesImage: true, mapUsesImage: true, iconSrc: "photos/gatling.level1.png", mapImageBase: "photos/gatling.level", firesInFixedDirections: true, fixedAngles: [ -Math.PI / 2, -Math.PI / 4, Math.PI / 4, Math.PI / 2, 3 * Math.PI / 4, -3 * Math.PI / 4 ], upgrades: { level2: { title: "Faster Spin", description: "Increases burst fire rate.", }, level3: { title: "AP Rounds", description: "Increases damage per shot.", }, }, level4: { name: "Overdrive Gatling", title: "Overdrive Engine", description: "Unleashes an overwhelming hail of bullets at extreme speed.", damageMultiplier: 1.3, rangeMultiplier: 1.0, fireRateMultiplier: 3.0, mapImage: "photos/gatling.level4.png" } } };
    const BOSS_TYPES = { JUGGERNAUT: { id: "JUGGERNAUT", name: "The Juggernaut", isBoss: true, baseHp: () => 5000 + gameState.wave * 150, speed: () => config.TILE_SIZE * (0.4 * 1.5), color: "#4A4A4A", size: () => Math.max(15, config.TILE_SIZE * 0.6), goldReward: 250, visuals: { coreColor: "#FF0000", crackColor: "#222222" } }, SHIELDED: { id: "SHIELDED", name: "The Shielded", isBoss: true, baseHp: () => 5000 + gameState.wave * 120, speed: () => config.TILE_SIZE * (0.5 * 1.5), color: "#0077CC", size: () => Math.max(12, config.TILE_SIZE * 0.5), goldReward: 200, visuals: { shieldColor: "rgba(173, 216, 230, 0.5)" }, abilities: { hasShield: true, shieldHpRatio: 0.5 } }, SWARM_CORE: { id: "SWARM_CORE", name: "The Swarm Core", isBoss: true, baseHp: () => 3000 + gameState.wave * 100, speed: () => config.TILE_SIZE * (0.45 * 1.5), color: "#8A2BE2", size: () => Math.max(10, config.TILE_SIZE * 0.4), goldReward: 180, visuals: { satelliteColor: "#696969" }, abilities: { spawnsMinions: true, spawnInterval: 5000, maxSatellites: 4 } }, INFERNO: { id: "INFERNO", name: "The Inferno", isBoss: true, baseHp: () => 3800 + gameState.wave * 130, speed: () => config.TILE_SIZE * (0.6 * 1.5), color: "#FF4500", size: () => Math.max(13, config.TILE_SIZE * 0.55), goldReward: 220, visuals: { particleColors: ["#FFA500", "#FF6347", "#FFD700"] }, abilities: { hasParticles: true, leavesTrail: false } }, MIRROR: { id: "MIRROR", name: "The Mirror", isBoss: true, baseHp: () => 3300 + gameState.wave * 110, speed: () => config.TILE_SIZE * (0.55 * 1.5), color: "#C0C0C0", size: () => Math.max(11, config.TILE_SIZE * 0.45), goldReward: 190, visuals: { pulseColor: "#FFFFFF" }, abilities: { reflects: true, reflectChance: 0.15 } }, LEECH: { id: "LEECH", name: "The Leech", isBoss: true, baseHp: () => 3000 + gameState.wave * 115, speed: () => config.TILE_SIZE * (0.4 * 1.5), color: "#556B2F", size: () => Math.max(12, config.TILE_SIZE * 0.5), goldReward: 210, visuals: { pulseIntensity: 0.1 }, abilities: { leeches: true, leechRange: () => config.TILE_SIZE * 3, leechHealAmount: 50 } } };
    const ENEMY_TYPES = { RED_CIRCLE: { id: "RED_CIRCLE", name: "Red Circle", baseHp: () => 30 + gameState.wave * 3, speed: () => config.TILE_SIZE * (1.10 * 1.75), color: "#e53e3e", goldReward: 2, size: () => Math.max(4, config.TILE_SIZE * 0.20) }, BLUE_CIRCLE: { id: "BLUE_CIRCLE", name: "Blue Circle", baseHp: () => 65 + gameState.wave * 6, speed: () => config.TILE_SIZE * (0.90 * 1.75), color: "#63b3ed", goldReward: 3, size: () => Math.max(5, config.TILE_SIZE * 0.25) }, GREEN_CIRCLE: { id: "GREEN_CIRCLE", name: "Green Circle", baseHp: () => 150 + gameState.wave * 10, speed: () => config.TILE_SIZE * (0.70 * 1.75), color: "#38A169", goldReward: 5, size: () => Math.max(6, config.TILE_SIZE * 0.30) }, PINK_CIRCLE: { id: "PINK_CIRCLE", name: "Pink Circle", baseHp: () => 300 + gameState.wave * 15, speed: () => config.TILE_SIZE * (0.65 * 1.75), color: "#FF69B4", goldReward: 7, size: () => Math.max(7, config.TILE_SIZE * 0.32) }, PURPLE_CIRCLE: { id: "PURPLE_CIRCLE", name: "Purple Circle", baseHp: () => 450 + gameState.wave * 25, speed: () => config.TILE_SIZE * (0.60 * 1.75), color: "#8A2BE2", goldReward: 10, size: () => Math.max(8, config.TILE_SIZE * 0.34) }, ORANGE_CIRCLE: { id: "ORANGE_CIRCLE", name: "Orange Circle", baseHp: () => 650 + gameState.wave * 40, speed: () => config.TILE_SIZE * (0.55 * 1.75), color: "#FFA500", goldReward: 15, size: () => Math.max(9, config.TILE_SIZE * 0.36) }, YELLOW_CIRCLE: { id: "YELLOW_CIRCLE", name: "Yellow Circle", baseHp: () => 1500 + gameState.wave * 60, speed: () => config.TILE_SIZE * (0.50 * 1.75), color: "#FFD700", goldReward: 20, size: () => Math.max(10,config.TILE_SIZE * 0.38) }, SATELLITE: { id: "SATELLITE", name: "Satellite", baseHp: () => 10 + gameState.wave * 1, speed: () => config.TILE_SIZE * (1.30 * 1.75), color: "#696969", goldReward: 0, size: () => Math.max(3, config.TILE_SIZE * 0.10), isSatellite: true } };
    function definePath() { const waypointsTile = [ { r: 2, c: -1 }, { r: 2, c: 2 }, { r: 5, c: 2 }, { r: 5, c: 5 }, { r: 3, c: 5 }, { r: 3, c: 7 }, { r: 5, c: 7 }, { r: 5, c: 5 }, { r: 7, c: 5 }, { r: 7, c: 15 }, { r: 4, c: 15 }, { r: 4, c: 17 }, { r: 2, c: 17 }, { r: 2, c: 19 }, { r: 4, c: 19 }, { r: 10, c: 19}, { r: 10, c: 14 }, { r: 12, c: 14 }, { r: 12, c: config.MAP_WIDTH_TILES } ]; gameState.path = waypointsTile.map(p => getPixelCoordsFromTile(p.r, p.c, true)); gameState.pathTiles.clear(); for (let i = 0; i < waypointsTile.length - 1; i++) { const start = waypointsTile[i]; const end = waypointsTile[i+1]; if (start.r === end.r) { const r = start.r; const cMin = Math.min(start.c, end.c); const cMax = Math.max(start.c, end.c); for (let c = cMin; c <= cMax; c++) { if(c >= 0 && c < config.MAP_WIDTH_TILES && r >= 0 && r < config.MAP_HEIGHT_TILES) gameState.pathTiles.add(`${r},${c}`); } } else if (start.c === end.c) { const c = start.c; const rMin = Math.min(start.r, end.r); const rMax = Math.max(start.r, end.r); for (let r = rMin; r <= rMax; r++) { if(r >= 0 && r < config.MAP_HEIGHT_TILES && c >= 0 && c < config.MAP_WIDTH_TILES) gameState.pathTiles.add(`${r},${c}`); } } } const lastOnMapWp = waypointsTile[waypointsTile.length - 2]; if (lastOnMapWp.r >= 0 && lastOnMapWp.r < config.MAP_HEIGHT_TILES && lastOnMapWp.c >= 0 && lastOnMapWp.c < config.MAP_WIDTH_TILES) { gameState.pathTiles.add(`${lastOnMapWp.r},${lastOnMapWp.c}`); } }
    function distance(x1, y1, x2, y2) { return Math.hypot(x1 - x2, y1 - y2); }
    function getTileCoordsFromPixels(pixelX, pixelY) { return { row: Math.floor(pixelY / config.TILE_SIZE), col: Math.floor(pixelX / config.TILE_SIZE) }; }
    function getPixelCoordsFromTile(row, col, center = true) { const x = col * config.TILE_SIZE; const y = row * config.TILE_SIZE; return center ? { x: x + config.TILE_SIZE / 2, y: y + config.TILE_SIZE / 2 } : { x, y }; }
    function isTileOnPath(row, col) { return gameState.pathTiles.has(`${row},${col}`); }
    function isTileOccupied(row, col) { return gameState.occupiedTiles.has(`${row},${col}`); }
    function isTileValidForPlacement(row, col) { if (row < 0 || row >= config.MAP_HEIGHT_TILES || col < 0 || col >= config.MAP_WIDTH_TILES) return false; return !isTileOnPath(row, col) && !isTileOccupied(row, col); }
    function isTileInTunnel(row, col) { const tunnelRow = 7; const tunnelStartCol = 8; const tunnelEndCol = 12; return row === tunnelRow && col >= tunnelStartCol && col <= tunnelEndCol; }
    function showMessage(msg, duration = 2500) { if (gameState.messageTimeout) clearTimeout(gameState.messageTimeout); messageBox.textContent = msg; messageBox.style.display = "block"; gameState.messageTimeout = setTimeout(() => { messageBox.style.display = "none"; gameState.messageTimeout = null; }, duration); }
    function getVisualCanvasProperties() { const containerW = canvasContainer.clientWidth; const containerH = canvasContainer.clientHeight; const internalW = canvas.width; const internalH = canvas.height; if (!containerW || !containerH || !internalW || !internalH || internalW <= 0 || internalH <= 0) { console.warn("Could not get valid canvas/container dimensions for visual scaling."); return { scale: 1, offsetX: 0, offsetY: 0, renderedW: internalW, renderedH: internalH }; } const scale = Math.min(containerW / internalW, containerH / internalH); const renderedW = internalW * scale; const renderedH = internalH * scale; const offsetX = (containerW - renderedW) / 2; const offsetY = (containerH - renderedH) / 2; return { scale, offsetX, offsetY, renderedW, renderedH }; }
    function updateRangePreview(internalX, internalY, internalRange, isValid = true) { if (internalRange > 0 && (gameState.placingTowerType || gameState.selectedTower)) { const { scale, offsetX, offsetY } = getVisualCanvasProperties(); const visualX = internalX * scale + offsetX; const visualY = internalY * scale + offsetY; const visualDiameter = internalRange * 2 * scale; rangePreviewCircle.style.width = `${visualDiameter}px`; rangePreviewCircle.style.height = `${visualDiameter}px`; rangePreviewCircle.style.left = `${visualX}px`; rangePreviewCircle.style.top = `${visualY}px`; rangePreviewCircle.style.display = "block"; rangePreviewCircle.classList.toggle("invalid-placement", !isValid); } else { rangePreviewCircle.style.display = "none"; } }
    function hideRangePreview() { rangePreviewCircle.style.display = "none"; }
    function updateSelectionHighlight(tower) { if (tower) { const { scale, offsetX, offsetY } = getVisualCanvasProperties(); const { x: internalX, y: internalY } = getPixelCoordsFromTile(tower.row, tower.col, true); const visualX = internalX * scale + offsetX; const visualY = internalY * scale + offsetY; const visualSize = config.TILE_SIZE * scale; selectionHighlight.style.left = `${visualX}px`; selectionHighlight.style.top = `${visualY}px`; selectionHighlight.style.width = `${visualSize}px`; selectionHighlight.style.height = `${visualSize}px`; selectionHighlight.style.display = "block"; } else { selectionHighlight.style.display = "none"; } }
    function updatePlacementPreview(show, typeId = null, internalTileX = 0, internalTileY = 0) { if (show && typeId) { const { scale, offsetX, offsetY } = getVisualCanvasProperties(); const visualX = internalTileX * scale + offsetX; const visualY = internalTileY * scale + offsetY; const visualSize = config.TILE_SIZE * scale; placementPreviewDiv.style.left = `${visualX}px`; placementPreviewDiv.style.top = `${visualY}px`; placementPreviewDiv.style.width = `${visualSize}px`; placementPreviewDiv.style.height = `${visualSize}px`; const typeInfo = TOWER_TYPES[typeId]; placementPreviewCtx.clearRect(0, 0, placementPreviewCanvas.width, placementPreviewCanvas.height); placementPreviewCtx.imageSmoothingEnabled = false; const initialAngle = typeInfo.initialAngle ?? -Math.PI / 2; drawTowerOnCanvas(placementPreviewCtx, typeInfo, placementPreviewCanvas.width / 2, placementPreviewCanvas.height / 2, 1, initialAngle, null); placementPreviewDiv.style.display = "block"; } else { placementPreviewDiv.style.display = "none"; } }
    // --- MODIFIED: calculateTowerStats Function ---
    function calculateTowerStats(typeId, level = 1, upgradePath = null) {
        const base = TOWER_TYPES[typeId];
        const baseCost = typeof base.baseCost === 'function' ? base.baseCost() : base.baseCost;
        const baseDamage = typeof base.baseDamage === 'function' ? base.baseDamage() : base.baseDamage;
        const baseRange = typeof base.baseRange === 'function' ? base.baseRange() : base.baseRange;
        const baseFireRate = typeof base.baseFireRate === 'function' ? base.baseFireRate() : base.baseFireRate;

        let currentDamage = baseDamage;
        let currentRange = baseRange;
        let currentFireRate = baseFireRate;

        // Calculate stats based on generic level progression (up to level 3 or max level if no L4 paths)
        const maxGenericLevel = (base.level4_bigarrows || base.level4_icebow || base.level4_dragon || base.level4_double || base.level4) ? 3 : base.upgradeLevels;
        for (let i = 1; i < Math.min(level, maxGenericLevel + 1); i++) {
            let damageMultiplier = config.TOWER_UPGRADE_STAT_MULTIPLIER;
            let rangeMultiplier = 1.1;
            let fireRateMultiplier = 1.1;

            // Specific tower/level stat adjustments
            if (i === 1 && base.id === 'CANNON') { rangeMultiplier = 1.05; fireRateMultiplier = 1.35; }
            if (i === 1 && base.id === 'CROSSBOW') { damageMultiplier *= 1.4; fireRateMultiplier = 1.15; }
            if (i === 2 && base.id === 'CROSSBOW') { damageMultiplier *= 1.2; fireRateMultiplier = 1.05; }
            if (base.id === 'GATLING') {
                if (i === 1) fireRateMultiplier = 1.3;
                if (i === 2) { damageMultiplier *= 1.35; fireRateMultiplier = 1.1; }
            }
            if (base.id === 'LASER') {
                if (i === 1) { damageMultiplier *= 1.3; rangeMultiplier=1.05; fireRateMultiplier=1.0; }
                if (i === 2) { damageMultiplier *= 1.4; rangeMultiplier=1.05; fireRateMultiplier=1.0; }
            }

            currentDamage = base.isBeam ? Math.round(currentDamage * damageMultiplier * 10) / 10 : Math.round(currentDamage * damageMultiplier);
            currentRange *= rangeMultiplier;
            currentFireRate *= fireRateMultiplier;
        }

        let pathInfo = null;
        let appliesSlow = false;
        let slowAmount = 0;
        let slowDuration = 0;
        let splashSlow = false;
        let splashSlowRadius = 0;
        let splashSlowMultiplier = 0.5;

        // Apply Level 4 path stats if applicable
        if (level === 4) {
            if (upgradePath && (base.id === 'CANNON' || base.id === 'CROSSBOW')) {
                pathInfo = base[`level4_${upgradePath}`];
            } else if (base.level4 && (base.id === 'LASER' || base.id === 'GATLING')) {
                pathInfo = base.level4;
            }

            if (pathInfo) {
                currentDamage = Math.round(currentDamage * (pathInfo.damageMultiplier || 1.0));
                currentRange *= (pathInfo.rangeMultiplier || 1.0);
                currentFireRate *= (pathInfo.fireRateMultiplier || 1.0);
                if (pathInfo.appliesSlow) {
                    appliesSlow = true;
                    slowAmount = pathInfo.slowAmount || 0;
                    slowDuration = pathInfo.slowDuration || 0;
                }
                if (pathInfo.splashSlow) {
                    splashSlow = true;
                    splashSlowRadius = typeof pathInfo.splashSlowRadius === 'function' ? pathInfo.splashSlowRadius() : 0;
                    splashSlowMultiplier = pathInfo.splashSlowMultiplier || 0.5;
                }
            } else if (upgradePath) {
                console.error(`Invalid upgrade path "${upgradePath}" for ${base.id} L4`);
            }
        }

        // Calculate the cost of the *next* upgrade
        let calculatedNextUpgradeCost = Infinity;
        let costOfPrevUpgrade = baseCost;
        for (let currentLevelCalc = 1; currentLevelCalc < base.upgradeLevels; currentLevelCalc++) {
            let costToUpgradeToNext;

            // <<< MODIFIED: Cannon Cost Logic >>>
            if (typeId === 'CANNON') {
                if (currentLevelCalc + 1 === 3) { // Cost to upgrade from L2 to L3
                    costToUpgradeToNext = Math.floor(costOfPrevUpgrade * config.TOWER_UPGRADE_COST_MULTIPLIER) + 100; // Add 100 gold
                } else if (currentLevelCalc + 1 === 4) { // Cost to upgrade from L3 to L4 (both paths)
                    costToUpgradeToNext = 1500; // Fixed cost
                } else { // Default cost calculation for L1 to L2
                    costToUpgradeToNext = Math.floor(costOfPrevUpgrade * config.TOWER_UPGRADE_COST_MULTIPLIER);
                }
            } else { // Default cost calculation for other towers
                costToUpgradeToNext = Math.floor(costOfPrevUpgrade * config.TOWER_UPGRADE_COST_MULTIPLIER);
                // Generic L4 cost adjustment (if not Cannon)
                if (currentLevelCalc + 1 === 4) {
                    costToUpgradeToNext = Math.max(1000, costToUpgradeToNext);
                }
            }
            // <<< END MODIFIED: Cannon Cost Logic >>>


            if (currentLevelCalc === level) { // If the loop reaches the tower's current level, this is the cost for the *next* upgrade
                calculatedNextUpgradeCost = costToUpgradeToNext;
                break;
            }
            costOfPrevUpgrade = costToUpgradeToNext; // Store the cost of upgrading *to* this level for the next iteration
        }

        if (level >= base.upgradeLevels) { // If already max level, no next upgrade cost
            calculatedNextUpgradeCost = Infinity;
        }

        // Calculate total investment and sell value (using the separate function)
        const totalInvestment = calculateTotalInvestment(typeId, level, upgradePath);
        const sellValue = Math.floor(totalInvestment * config.SELL_RETURN_RATIO);

        // Determine splash properties based on L4 path
        const isSplashDamage = pathInfo?.isSplashDamage ?? false;
        const splashRadius = (isSplashDamage && typeof pathInfo.splashRadius === 'function') ? pathInfo.splashRadius() : 0;
        const maxSplashTargets = isSplashDamage ? pathInfo.maxSplashTargets : 0;

        return {
            level,
            maxLevel: base.upgradeLevels,
            damage: currentDamage,
            range: currentRange,
            fireRate: currentFireRate,
            nextUpgradeCost: calculatedNextUpgradeCost,
            sellValue: sellValue,
            isSplashDamage: isSplashDamage,
            splashRadius: splashRadius,
            maxSplashTargets: maxSplashTargets,
            appliesSlow: appliesSlow,
            slowAmount: slowAmount,
            slowDuration: slowDuration,
            splashSlow: splashSlow,
            splashSlowRadius: splashSlowRadius,
            splashSlowMultiplier: splashSlowMultiplier
        };
    }
    // --- END MODIFIED: calculateTowerStats Function ---

    // --- MODIFIED: calculateTotalInvestment Function ---
    // This function needs to mirror the cost logic in calculateTowerStats to get the correct total
    function calculateTotalInvestment(typeId, level, upgradePath = null) {
        const base = TOWER_TYPES[typeId];
        const baseCost = typeof base.baseCost === 'function' ? base.baseCost() : base.baseCost;
        let totalCost = baseCost;
        let costOfPreviousLevelUpgrade = baseCost; // Cost to build/upgrade to Level 1

        for (let i = 1; i < level; i++) { // Loop up to the current level - 1
            let currentUpgradeCost;
            const upgradingToLevel = i + 1; // The level being upgraded TO in this iteration

            // <<< MODIFIED: Cannon Cost Logic (Mirrored from calculateTowerStats) >>>
            if (typeId === 'CANNON') {
                if (upgradingToLevel === 3) { // Cost to upgrade TO L3
                    currentUpgradeCost = Math.floor(costOfPreviousLevelUpgrade * config.TOWER_UPGRADE_COST_MULTIPLIER) + 100;
                } else if (upgradingToLevel === 4) { // Cost to upgrade TO L4
                    currentUpgradeCost = 1500;
                } else { // Cost to upgrade TO L2
                    currentUpgradeCost = Math.floor(costOfPreviousLevelUpgrade * config.TOWER_UPGRADE_COST_MULTIPLIER);
                }
            } else { // Default cost calculation for other towers
                 currentUpgradeCost = Math.floor(costOfPreviousLevelUpgrade * config.TOWER_UPGRADE_COST_MULTIPLIER);
                 // Generic L4 cost adjustment (if not Cannon)
                 if (upgradingToLevel === 4) {
                     currentUpgradeCost = Math.max(1000, currentUpgradeCost);
                 }
            }
            // <<< END MODIFIED: Cannon Cost Logic >>>

            totalCost += currentUpgradeCost;
            costOfPreviousLevelUpgrade = currentUpgradeCost; // Update for the next iteration
        }
        return totalCost;
    }
    // --- END MODIFIED: calculateTotalInvestment Function ---

    class Enemy { constructor(type, waveNum) { this.id = type + "_" + Math.random().toString(36).substring(2, 9); const enemyTypeData = ENEMY_TYPES[type] || BOSS_TYPES[type]; if (!enemyTypeData) { console.error("Unknown type:", type); this.isAlive = false; return; } this.type = type; this.isBoss = enemyTypeData.isBoss || false; this.isSatellite = enemyTypeData.isSatellite || false; this.visuals = enemyTypeData.visuals || {}; this.abilities = enemyTypeData.abilities || {}; this.x = gameState.path[0].x; this.y = gameState.path[0].y; this.pathIndex = 0; this.baseHp = typeof enemyTypeData.baseHp === 'function' ? enemyTypeData.baseHp() : enemyTypeData.baseHp; if (!this.isBoss && !this.isSatellite && waveNum >= HEALTH_SCALING_START_WAVE) { const scalingFactor = 1.1 * waveNum; this.baseHp *= Math.max(1, scalingFactor); this.baseHp = Math.round(this.baseHp); } this.maxHp = this.baseHp; this.currentHp = this.maxHp; this.baseSpeed = typeof enemyTypeData.speed === 'function' ? enemyTypeData.speed() : enemyTypeData.speed; this.speed = this.baseSpeed; this.color = enemyTypeData.color; this.size = typeof enemyTypeData.size === 'function' ? enemyTypeData.size() : enemyTypeData.size; this.goldReward = enemyTypeData.goldReward; this.isAlive = true; this.distanceTraveled = 0; this.slowMultiplier = 1.0; this.slowDuration = 0; this.slowEffectExpiryTime = 0; if (this.abilities.hasShield) { this.shieldHp = this.maxHp * (this.abilities.shieldHpRatio || 0.5); this.maxShieldHp = this.shieldHp; } if (this.abilities.spawnsMinions) { this.satelliteSpawnCooldown = this.abilities.spawnInterval || 5000; this.lastSpawnTime = Date.now(); gameState.activeSatellites.set(this.id, []); } if (this.abilities.hasParticles) { this.particles = []; } if (this.abilities.reflects) { this.isReflecting = false; this.reflectCooldown = 0; } } update(deltaTime) { if (!this.isAlive) return; const now = Date.now(); if (this.slowDuration > 0) { if (now >= this.slowEffectExpiryTime) { this.slowMultiplier = 1.0; this.slowDuration = 0; this.speed = this.baseSpeed; } else { this.speed = this.baseSpeed * this.slowMultiplier; } } else { this.speed = this.baseSpeed; } if (this.abilities.spawnsMinions) { this.updateSwarmCore(deltaTime); } if (this.abilities.hasParticles) { this.updateInfernoParticles(deltaTime); } if (this.abilities.reflects) { this.updateMirrorReflect(deltaTime); } if (this.abilities.leeches) { this.updateLeech(deltaTime); } this.move(deltaTime); } move(deltaTime) { if (!this.isAlive || this.pathIndex >= gameState.path.length - 1) { if (this.isSatellite) this.isAlive = false; return; } if (this.isSatellite && this.parentId && gameState.enemies.some(e => e.id === this.parentId && e.isAlive)) { const parent = gameState.enemies.find(e => e.id === this.parentId); if (parent) { const orbitRadius = parent.size * 1.5; const orbitSpeed = (2 * Math.PI / 5) * deltaTime * gameState.gameSpeed; this.orbitAngle = (this.orbitAngle || 0) + orbitSpeed; this.x = parent.x + Math.cos(this.orbitAngle) * orbitRadius; this.y = parent.y + Math.sin(this.orbitAngle) * orbitRadius; return; } else { this.isAlive = false; return; } } const targetWaypoint = gameState.path[this.pathIndex + 1]; const dx = targetWaypoint.x - this.x; const dy = targetWaypoint.y - this.y; const distToWaypoint = Math.hypot(dx, dy); const moveDistance = this.speed * deltaTime * gameState.gameSpeed; if (moveDistance >= distToWaypoint) { this.x = targetWaypoint.x; this.y = targetWaypoint.y; this.pathIndex++; this.distanceTraveled += distToWaypoint; if (this.pathIndex >= gameState.path.length - 1) { this.reachEnd(); } else { const remainingMove = moveDistance - distToWaypoint; if (remainingMove > 0 && this.pathIndex < gameState.path.length - 1) { const nextTarget = gameState.path[this.pathIndex + 1]; const nextDx = nextTarget.x - this.x; const nextDy = nextTarget.y - this.y; const nextAngle = Math.atan2(nextDy, nextDx); this.x += Math.cos(nextAngle) * remainingMove; this.y += Math.sin(nextAngle) * remainingMove; this.distanceTraveled += remainingMove; } } } else { const angle = Math.atan2(dy, dx); this.x += Math.cos(angle) * moveDistance; this.y += Math.sin(angle) * moveDistance; this.distanceTraveled += moveDistance; } } draw(ctx) { if (!this.isAlive) return; let drawSize = this.size; if (this.abilities.leeches) { const pulse = Math.sin(Date.now() * 0.005) * (this.visuals.pulseIntensity || 0.1); drawSize = this.size * (1 + pulse); } if (this.slowDuration > 0) { ctx.save(); const slowIntensity = (this.slowEffectExpiryTime - Date.now()) / this.slowDuration; ctx.fillStyle = `rgba(100, 150, 255, ${0.2 + slowIntensity * 0.3})`; ctx.beginPath(); ctx.arc(this.x, this.y, drawSize * 1.1, 0, Math.PI * 2); ctx.fill(); ctx.restore(); } ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, drawSize, 0, Math.PI * 2); ctx.fill(); if (this.isBoss) { ctx.save(); switch (this.type) { case 'JUGGERNAUT': ctx.strokeStyle = this.visuals.crackColor || "#222"; ctx.lineWidth = Math.max(1, drawSize * 0.05); for (let i = 0; i < 5; i++) { ctx.beginPath(); const sa = Math.random() * Math.PI * 2; const ea = sa + (Math.random() - 0.5) * 1.5; const cl = drawSize * (0.6 + Math.random() * 0.4); ctx.moveTo(this.x + Math.cos(sa) * drawSize * 0.3, this.y + Math.sin(sa) * drawSize * 0.3); ctx.lineTo(this.x + Math.cos(ea) * cl, this.y + Math.sin(ea) * cl); ctx.stroke(); } ctx.fillStyle = this.visuals.coreColor || "#FF0000"; ctx.filter = 'blur(3px)'; ctx.beginPath(); ctx.arc(this.x, this.y, drawSize * 0.3, 0, Math.PI * 2); ctx.fill(); ctx.filter = 'none'; break; case 'SHIELDED': if (this.shieldHp > 0) { ctx.strokeStyle = this.visuals.shieldColor || "rgba(173, 216, 230, 0.5)"; ctx.lineWidth = Math.max(2, drawSize * 0.1); const sr = drawSize * 1.2; const rot = (Date.now() * 0.001) % (Math.PI * 2); ctx.beginPath(); ctx.arc(this.x, this.y, sr, rot, rot + Math.PI * 1.5); ctx.stroke(); ctx.beginPath(); ctx.arc(this.x, this.y, sr * 0.9, rot + Math.PI, rot + Math.PI * 2.5); ctx.stroke(); } break; case 'INFERNO': if (this.particles) { this.particles.forEach((p, index) => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life / p.maxLife; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); p.x += p.vx * deltaTime * gameState.gameSpeed; p.y += p.vy * deltaTime * gameState.gameSpeed; p.life -= deltaTime * 1000 * gameState.gameSpeed; if (p.life <= 0) { this.particles.splice(index, 1); } }); ctx.globalAlpha = 1.0; } break; case 'MIRROR': ctx.fillStyle = this.isReflecting ? 'rgba(255,255,255,0.6)' : 'rgba(200,200,255,0.3)'; const ps = this.isReflecting ? 1.3 : 1.1 + Math.sin(Date.now() * 0.003) * 0.1; ctx.beginPath(); ctx.arc(this.x, this.y, drawSize * ps * 0.8, 0, Math.PI * 2); ctx.fill(); let grad = ctx.createRadialGradient(this.x - drawSize * 0.2, this.y - drawSize * 0.3, drawSize * 0.1, this.x, this.y, drawSize * 1.1); grad.addColorStop(0, 'rgba(255,255,255,0.7)'); grad.addColorStop(0.5, 'rgba(200,200,255,0.2)'); grad.addColorStop(1, 'rgba(180,180,200,0.0)'); ctx.fillStyle = grad; ctx.fill(); break; } ctx.restore(); } const hpRatio = this.currentHp / this.maxHp; if (hpRatio < 1 || this.isBoss) { const bw = Math.max(drawSize * 1.5, config.TILE_SIZE * 0.8); const bh = Math.max(3, drawSize * 0.15); const bx = this.x - bw / 2; const by = this.y - drawSize - bh - 3; ctx.fillStyle = '#4A5568'; ctx.fillRect(bx, by, bw, bh); ctx.fillStyle = hpRatio > 0.5 ? '#48BB78' : (hpRatio > 0.2 ? '#F6E05E' : '#F56565'); ctx.fillRect(bx, by, bw * hpRatio, bh); if (this.abilities.hasShield && this.maxShieldHp > 0) { const sr = this.shieldHp / this.maxShieldHp; const sby = by - bh - 1; ctx.fillStyle = '#60A5FA'; ctx.fillRect(bx, sby, bw, bh); ctx.fillStyle = '#BFDBFE'; ctx.fillRect(bx, sby, bw * sr, bh); } } } takeDamage(amount) { if (!this.isAlive) return 0; if (this.abilities.reflects && this.isReflecting) { this.reflectCooldown = 500; this.isReflecting = false; return 0; } let damageDealt = amount; if (this.abilities.hasShield && this.shieldHp > 0) { const dts = Math.min(this.shieldHp, amount); this.shieldHp -= dts; damageDealt = amount - dts; if (damageDealt <= 0) { return 0; } } const actualDamage = Math.min(this.currentHp, damageDealt); this.currentHp -= actualDamage; if (this.currentHp <= 0) { this.die(); } return actualDamage; } applySlow(multiplier, duration) { if (!this.isAlive) return; const now = Date.now(); const newExpiryTime = now + duration; if (multiplier < this.slowMultiplier || newExpiryTime > this.slowEffectExpiryTime) { this.slowMultiplier = multiplier; this.slowDuration = duration; this.slowEffectExpiryTime = newExpiryTime; this.speed = this.baseSpeed * this.slowMultiplier; } } die() { if (!this.isAlive) return; this.isAlive = false; gameState.gold += this.goldReward; gameState.defeatedThisWave++; gameState.deadEnemyPositions.push({ x: this.x, y: this.y, time: Date.now() }); if (gameState.deadEnemyPositions.length > 50) { gameState.deadEnemyPositions = gameState.deadEnemyPositions.filter(p => Date.now() - p.time < 5000); } if (this.abilities.spawnsMinions) { const sats = gameState.activeSatellites.get(this.id) || []; sats.forEach(sat => { if (sat && sat.isAlive) sat.isAlive = false; }); gameState.activeSatellites.delete(this.id); } if (this.isSatellite && this.parentId) { const parentSats = gameState.activeSatellites.get(this.parentId); if (parentSats) { const index = parentSats.findIndex(sat => sat.id === this.id); if (index > -1) { parentSats.splice(index, 1); } } } updateUI(); } reachEnd() { if (!this.isAlive) return; const lifeDamage = this.isBoss ? 10 : 1; this.isAlive = false; gameState.lives -= lifeDamage; gameState.reachedEndThisWave++; updateUI(); if (gameState.lives <= 0) { gameOver(); } } updateSwarmCore(deltaTime) { this.satelliteSpawnCooldown -= deltaTime * 1000 * gameState.gameSpeed; const currentSatellites = gameState.activeSatellites.get(this.id) || []; if (this.satelliteSpawnCooldown <= 0 && currentSatellites.length < (this.abilities.maxSatellites || 4)) { this.lastSpawnTime = Date.now(); this.satelliteSpawnCooldown = this.abilities.spawnInterval || 5000; const satellite = new Enemy('SATELLITE', gameState.wave); satellite.parentId = this.id; const angle = Math.random() * Math.PI * 2; const radius = this.size * 1.2; satellite.x = this.x + Math.cos(angle) * radius; satellite.y = this.y + Math.sin(angle) * radius; satellite.orbitAngle = angle; gameState.enemies.push(satellite); currentSatellites.push(satellite); gameState.activeSatellites.set(this.id, currentSatellites); } } updateInfernoParticles(deltaTime) { if (Math.random() < 0.8) { const pLife = 500 + Math.random() * 500; const pAngle = Math.random() * Math.PI * 2; const pSpeed = this.size * (0.1 + Math.random() * 0.2); const pColor = this.visuals.particleColors[Math.floor(Math.random() * this.visuals.particleColors.length)]; this.particles.push({ x: this.x + (Math.random() - 0.5) * this.size * 0.5, y: this.y + (Math.random() - 0.5) * this.size * 0.5, vx: Math.cos(pAngle) * pSpeed, vy: Math.sin(pAngle) * pSpeed, size: Math.max(1, this.size * (0.05 + Math.random() * 0.1)), color: pColor, life: pLife, maxLife: pLife }); } } updateMirrorReflect(deltaTime) { this.reflectCooldown = Math.max(0, this.reflectCooldown - deltaTime * 1000 * gameState.gameSpeed); if (this.reflectCooldown === 0 && Math.random() < 0.1 * deltaTime * gameState.gameSpeed) { this.isReflecting = true; this.reflectCooldown = 2000; } else if (this.reflectCooldown > 0 && this.isReflecting && this.reflectCooldown < 100) { this.isReflecting = false; } } updateLeech(deltaTime) { if (Math.random() < 0.1 * deltaTime * gameState.gameSpeed) { const healRangeSq = Math.pow((typeof this.abilities.leechRange === 'function' ? this.abilities.leechRange() : this.abilities.leechRange) || config.TILE_SIZE * 3, 2); for (let i = gameState.deadEnemyPositions.length - 1; i >= 0; i--) { const deadPos = gameState.deadEnemyPositions[i]; if (Date.now() - deadPos.time > 2000) { gameState.deadEnemyPositions.splice(i, 1); continue; } const distSq = Math.pow(this.x - deadPos.x, 2) + Math.pow(this.y - deadPos.y, 2); if (distSq <= healRangeSq) { const healAmount = this.abilities.leechHealAmount || 50; this.currentHp = Math.min(this.maxHp, this.currentHp + healAmount); gameState.deadEnemyPositions.splice(i, 1); break; } } } } }
    class Tower { constructor(typeId, row, col) { this.id = Math.random().toString(36).substring(2, 15); this.typeId = typeId; this.row = row; this.col = col; const { x, y } = getPixelCoordsFromTile(row, col, true); this.x = x; this.y = y; this.level = 1; this.upgradePath = null; this.typeInfo = TOWER_TYPES[typeId]; this.stats = calculateTowerStats(typeId, this.level); this.target = null; this.enemyInRange = false; this.fireCooldown = 0; this.angle = this.typeInfo.initialAngle ?? -Math.PI / 2; this.targetingMode = 'first'; this.totalDamageDealt = 0; const baseCost = typeof this.typeInfo.baseCost === 'function' ? this.typeInfo.baseCost() : this.typeInfo.baseCost; this.investment = baseCost; this.beamActive = false; this.beamTargetPos = { x: 0, y: 0 }; gameState.totalTowerInvestment.set(this.id, this.investment); } findTarget() { if (this.typeInfo.firesInFixedDirections) { this.enemyInRange = gameState.enemies.some(e => e.isAlive && distance(this.x, this.y, e.x, e.y) <= this.stats.range && !isTileInTunnel(getTileCoordsFromPixels(e.x, e.y).row, getTileCoordsFromPixels(e.x, e.y).col) ); this.target = null; this.beamActive = false; return; } let potTargs = gameState.enemies.filter(e => e.isAlive && !e.isSatellite && distance(this.x, this.y, e.x, e.y) <= this.stats.range ); if (potTargs.length === 0) { potTargs = gameState.enemies.filter(e => e.isAlive && distance(this.x, this.y, e.x, e.y) <= this.stats.range ); } potTargs = potTargs.filter(enemy => { const { row, col } = getTileCoordsFromPixels(enemy.x, enemy.y); return !isTileInTunnel(row, col); }); if (potTargs.length === 0) { this.target = null; this.beamActive = false; return; } switch (this.targetingMode) { case 'last': potTargs.sort((a, b) => a.distanceTraveled - b.distanceTraveled); break; case 'strongest': potTargs.sort((a, b) => b.currentHp - a.currentHp); break; case 'weakest': potTargs.sort((a, b) => { if (a.currentHp !== b.currentHp) return a.currentHp - b.currentHp; return b.distanceTraveled - a.distanceTraveled; }); break; case 'first': default: potTargs.sort((a, b) => b.distanceTraveled - a.distanceTraveled); break; } this.target = potTargs[0]; if (this.typeInfo.isBeam) { this.beamActive = !!this.target; if (this.target) this.beamTargetPos = { x: this.target.x, y: this.target.y }; } } update(deltaTime) { this.fireCooldown = Math.max(0, this.fireCooldown - deltaTime * gameState.gameSpeed); this.findTarget(); if (this.typeInfo.firesInFixedDirections) { if (this.enemyInRange && this.fireCooldown === 0) { this.fire(); const fireInterval = 1 / this.stats.fireRate; this.fireCooldown = isFinite(fireInterval) && fireInterval > 0 ? fireInterval : 1; } } else if (this.target) { const dx = this.target.x - this.x; const dy = this.target.y - this.y; if (!this.typeInfo.isBeam && !(this.typeInfo.mapUsesImage && !this.typeInfo.isMultipart && !this.typeInfo.firesInFixedDirections)) { this.angle = Math.atan2(dy, dx); } if (this.fireCooldown === 0) { this.fire(); if (!this.typeInfo.isBeam) { const fireInterval = 1 / this.stats.fireRate; this.fireCooldown = isFinite(fireInterval) && fireInterval > 0 ? fireInterval : 1; } } if (this.typeInfo.isBeam) { this.fire(); this.beamTargetPos = { x: this.target.x, y: this.target.y }; } } else { this.beamActive = false; } } fire() { let totalDamageThisCycle = 0; if (this.typeInfo.firesInFixedDirections) { if (!this.enemyInRange) return; const enemiesInRange = gameState.enemies.filter(e => e.isAlive && distance(this.x, this.y, e.x, e.y) <= this.stats.range && !isTileInTunnel(getTileCoordsFromPixels(e.x, e.y).row, getTileCoordsFromPixels(e.x, e.y).col) ); this.typeInfo.fixedAngles.forEach(angle => { let bestTargetForAngle = null; let minAngleDiff = Math.PI / 12; enemiesInRange.forEach(enemy => { const angleToEnemy = Math.atan2(enemy.y - this.y, enemy.x - this.x); let angleDiff = Math.abs(angle - angleToEnemy); if (angleDiff > Math.PI) { angleDiff = 2 * Math.PI - angleDiff; } if (angleDiff < minAngleDiff) { minAngleDiff = angleDiff; bestTargetForAngle = enemy; } }); const endX = this.x + Math.cos(angle) * this.stats.range; const endY = this.y + Math.sin(angle) * this.stats.range; createHitEffect( this.x, this.y, endX, endY, '#e2e8f0', this ); if (bestTargetForAngle) { const actualDamage = bestTargetForAngle.takeDamage(this.stats.damage); totalDamageThisCycle += actualDamage; } }); } else if (this.typeInfo.isBeam) { if (!this.target || !this.target.isAlive) { this.beamActive = false; return; } const dps = this.stats.damage; const dtf = dps * gameState.deltaTime * gameState.gameSpeed; const actualDamage = this.target.takeDamage(dtf); totalDamageThisCycle += actualDamage; this.beamActive = true; } else { if (!this.target || !this.target.isAlive) { return; } let mainTargetDamage = this.stats.damage; let actualDamage = this.target.takeDamage(mainTargetDamage); totalDamageThisCycle += actualDamage; if (this.stats.appliesSlow && actualDamage > 0) { this.target.applySlow(1.0 - this.stats.slowAmount, this.stats.slowDuration); } let barrelLenVal = config.TILE_SIZE * 0.4; let hitCol = '#FFFFFF'; if (this.typeId === 'CANNON') { barrelLenVal = (this.level <= 2) ? config.TILE_SIZE * 0.1 : (this.level === 3 ? config.TILE_SIZE * 0.15 : config.TILE_SIZE * 0.2); if (this.level === 4 && this.upgradePath === 'dragon') { hitCol = '#FF4500'; } else if (this.level === 4 && this.upgradePath === 'double') { hitCol = '#D2691E'; } else { hitCol = '#FFA500'; } } else if (this.typeId === 'CROSSBOW') { barrelLenVal = config.TILE_SIZE * 0.35; if (this.level === 4 && this.upgradePath === 'icebow') { hitCol = this.typeInfo.level4_icebow.projectileColor || '#63B3ED'; } else if (this.level === 4 && this.upgradePath === 'bigarrows') { hitCol = '#A0522D'; } else { hitCol = '#8B4513'; } } createHitEffect( this.x + Math.cos(this.angle) * barrelLenVal, this.y + Math.sin(this.angle) * barrelLenVal, this.target.x, this.target.y, hitCol, this ); if (this.stats.isSplashDamage && this.typeId === 'CANNON' && this.level === 4 && this.upgradePath === 'dragon' && actualDamage > 0) { const splashRadius = this.stats.splashRadius; const splashDamage = mainTargetDamage * 0.6; let splashTargetsHit = 0; const potentialSplashTargets = gameState.enemies.filter( enemy => enemy.isAlive && enemy.id !== this.target.id && distance(this.target.x, this.target.y, enemy.x, enemy.y) <= splashRadius && !isTileInTunnel(getTileCoordsFromPixels(enemy.x, enemy.y).row, getTileCoordsFromPixels(enemy.x, enemy.y).col) ); potentialSplashTargets.sort((a, b) => distance(this.target.x, this.target.y, a.x, a.y) - distance(this.target.x, this.target.y, b.x, b.y) ); for (const splashTarget of potentialSplashTargets) { if (splashTargetsHit >= this.stats.maxSplashTargets) break; const splashActualDamage = splashTarget.takeDamage(splashDamage); totalDamageThisCycle += splashActualDamage; splashTargetsHit++; spawnFireParticles(splashTarget.x, splashTarget.y, 5, 200); } } if (this.stats.splashSlow && this.typeId === 'CROSSBOW' && this.level === 4 && this.upgradePath === 'icebow' && actualDamage > 0) { const splashRadius = this.stats.splashSlowRadius; const splashSlowAmount = this.stats.slowAmount * this.stats.splashSlowMultiplier; const splashSlowDuration = this.stats.slowDuration; gameState.enemies.forEach(enemy => { if (enemy.isAlive && enemy.id !== this.target.id && distance(this.target.x, this.target.y, enemy.x, enemy.y) <= splashRadius) { enemy.applySlow(1.0 - splashSlowAmount, splashSlowDuration); } }); } } this.totalDamageDealt += totalDamageThisCycle; gameState.towerDamageTracker.set(this.id, (gameState.towerDamageTracker.get(this.id) || 0) + totalDamageThisCycle); } upgrade() { if (this.level >= this.stats.maxLevel) { showMessage("Tower is already max level!"); return false; } if (this.level === 3 && (this.typeId === 'CANNON' || this.typeId === 'CROSSBOW')) { showMessage("Choose a Level 4 specialization!"); return false; } const upgradeCost = this.stats.nextUpgradeCost; if (gameState.gold >= upgradeCost) { gameState.gold -= upgradeCost; this.level++; this.investment = calculateTotalInvestment(this.typeId, this.level); gameState.totalTowerInvestment.set(this.id, this.investment); this.stats = calculateTowerStats(this.typeId, this.level); updateUI(); updateTowerInfoPanel(this); showMessage(`${this.getName()} upgraded to Level ${this.level}!`); const { x, y } = getPixelCoordsFromTile(this.row, this.col, true); updateRangePreview(x, y, this.stats.range, true); return true; } else { showMessage("Not enough gold to upgrade!"); return false; } } finalizeUpgrade(pathChoice) { if (this.level !== 3 || !(this.typeId === 'CANNON' || this.typeId === 'CROSSBOW') || !pathChoice) { console.warn("Finalize upgrade called incorrectly.", this.typeId, this.level, pathChoice); return false; } const costCheckStats = calculateTowerStats(this.typeId, 3); // Recalculate stats for L3 to get the correct *next* cost (which is L4 cost)
        const upgradeCost = costCheckStats.nextUpgradeCost; if (gameState.gold >= upgradeCost) { gameState.gold -= upgradeCost; this.level = 4; this.upgradePath = pathChoice; this.investment = calculateTotalInvestment(this.typeId, this.level, this.upgradePath); gameState.totalTowerInvestment.set(this.id, this.investment); this.stats = calculateTowerStats(this.typeId, this.level, this.upgradePath); updateUI(); updateTowerInfoPanel(this); showMessage(`${this.getName()} upgraded to Level ${this.level}!`); const { x, y } = getPixelCoordsFromTile(this.row, this.col, true); updateRangePreview(x, y, this.stats.range, true); return true; } else { showMessage(`Not enough gold for Level 4 ${this.typeInfo.name}!`); return false; } } getName() { if (this.level === 4) { if (this.upgradePath && (this.typeId === 'CANNON' || this.typeId === 'CROSSBOW')) { const pathInfo = this.typeInfo[`level4_${this.upgradePath}`]; return pathInfo?.name ?? this.typeInfo.name; } else if (this.typeInfo.level4 && (this.typeId === 'LASER' || this.typeId === 'GATLING')) { return this.typeInfo.level4.name ?? this.typeInfo.name; } } return this.typeInfo.name; } draw(context) { const drawAngle = this.typeInfo.firesInFixedDirections ? (this.typeInfo.initialAngle ?? -Math.PI/2) : this.angle; drawTowerOnCanvas(context, this.typeInfo, this.x, this.y, this.level, drawAngle, this); if (this.typeInfo.isBeam && this.beamActive && this.target) { const originOffset = this.typeInfo.beamOriginOffset || { x: 0, y: 0 }; const originX = this.x + originOffset.x; const originY = this.y + originOffset.y; context.beginPath(); context.moveTo(originX, originY); context.lineTo(this.beamTargetPos.x, this.beamTargetPos.y); context.strokeStyle = this.typeInfo.projectileColor || '#ADFF2F'; context.lineWidth = this.typeInfo.projectileSize || 2; context.stroke(); context.lineWidth = 1; } } sell() { const sellValue=this.stats.sellValue; gameState.gold+=sellValue; gameState.occupiedTiles.delete(`${this.row},${this.col}`); gameState.towerDamageTracker.delete(this.id); gameState.totalTowerInvestment.delete(this.id); updateUI(); return true; } }
    function drawTowerOnCanvas(context, typeInfo, x, y, level, angle, towerInstance = null) { context.save(); context.translate(x, y); const size = config.TILE_SIZE; const applyScaling = true; let currentLevelParts = null; let isL4Path = false; const upgradePath = towerInstance?.upgradePath; if (level === 4) { if (upgradePath && (typeInfo.id === 'CANNON' || typeInfo.id === 'CROSSBOW')) { const pathKey = `level4_${upgradePath}`; currentLevelParts = typeInfo[pathKey]?.parts; isL4Path = !!currentLevelParts; } else if (typeInfo.level4 && (typeInfo.id === 'LASER' || typeInfo.id === 'GATLING')) { currentLevelParts = typeInfo.level4.parts; isL4Path = true; } } if (!isL4Path && level <= typeInfo.upgradeLevels && typeInfo.parts?.[`level${level}`]) { currentLevelParts = typeInfo.parts[`level${level}`]; } if (typeInfo.id === 'LASER' && typeInfo.mapUsesImage) { const imgKey = currentLevelParts?.image || typeInfo.parts?.[`level${level}`]?.image; const img = loadedImages[imgKey]; const drawWidth = size; const drawHeight = size; if (img && img.complete && img.naturalWidth > 0) { const fixedAngle = typeInfo.initialAngle ?? -Math.PI / 2; if (fixedAngle !== -Math.PI / 2) { context.rotate(fixedAngle + Math.PI / 2); } context.drawImage(img, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight); } else { context.fillStyle="#008B8B"; context.fillRect(-size*0.3,-size*0.3,size*0.6,size*0.6); console.warn(`Laser img not loaded L${level}: ${imgKey}`); } } else if (typeInfo.isMultipart && currentLevelParts && currentLevelParts.base && currentLevelParts.barrel) { const baseKey = currentLevelParts.base; const barrelKey = currentLevelParts.barrel; const baseImg = loadedImages[baseKey]; const barrelImg = loadedImages[barrelKey]; const naturalAngle = currentLevelParts.barrelNaturalAngle ?? -Math.PI / 2; const baseScale = currentLevelParts.baseScale ?? 1.0; const barrelScale = currentLevelParts.barrelScale ?? 1.0; const finalBaseWidth = applyScaling ? size * baseScale : size; const finalBaseHeight = applyScaling ? size * baseScale : size; const finalBarrelWidth = applyScaling ? size * barrelScale : size; const finalBarrelHeight = applyScaling ? size * barrelScale : size; const barrelOffsetX = currentLevelParts.barrelOffset?.x ?? 0; const barrelOffsetY = currentLevelParts.barrelOffset?.y ?? 0; if (baseImg && baseImg.complete && baseImg.naturalWidth > 0) { context.drawImage(baseImg, -finalBaseWidth / 2, -finalBaseHeight / 2, finalBaseWidth, finalBaseHeight); } else { context.fillStyle="#8B4513"; context.fillRect(-size*0.3,-size*0.1,size*0.6,size*0.4); console.warn(`${typeInfo.id} Base img not loaded L${level} Path(${upgradePath}): ${baseKey}`); } if (barrelImg && barrelImg.complete && barrelImg.naturalWidth > 0) { context.save(); const rotation = angle - naturalAngle; context.rotate(rotation); context.drawImage( barrelImg, -finalBarrelWidth / 2 + barrelOffsetX, -finalBarrelHeight / 2 + barrelOffsetY, finalBarrelWidth, finalBarrelHeight ); context.restore(); } else { context.save(); context.rotate(angle - naturalAngle); context.fillStyle="#2f2f2f"; context.fillRect(barrelOffsetX, -size*0.1 + barrelOffsetY, size*0.6, size*0.2); context.restore(); console.warn(`${typeInfo.id} Barrel img not loaded L${level} Path(${upgradePath}): ${barrelKey}`); } } else if (typeInfo.mapUsesImage && (typeInfo.mapImageBase || currentLevelParts?.mapImage) && level <= typeInfo.upgradeLevels) { const imgKey = currentLevelParts?.mapImage || `${typeInfo.mapImageBase}${level}.png`; const img = loadedImages[imgKey]; const finalWidth = size; const finalHeight = size; if (img && img.complete && img.naturalWidth > 0) { context.save(); if (!typeInfo.firesInFixedDirections) { context.rotate(angle + Math.PI / 2); } context.drawImage(img, -finalWidth / 2, -finalHeight / 2, finalWidth, finalHeight); context.restore(); } else { const fbSize=size*0.8; context.fillStyle = (typeInfo.id === 'GATLING') ? "#607D8B" : "#4682B4"; context.beginPath(); context.rect(-fbSize/2,-fbSize/2,fbSize,fbSize); context.fill(); console.warn(`Single img (base) not loaded: ${imgKey}`); } } else { const baseRadius = size * 0.35; const genBarrelLength = size * 0.4; const genBarrelWidth = size * 0.1; const towerColor = '#CCCCCC'; const barrelColor = '#000000'; context.fillStyle=towerColor; context.beginPath(); context.arc(0,0,baseRadius,0,Math.PI*2); context.fill(); context.strokeStyle=barrelColor; context.lineWidth=1; context.stroke(); context.save(); context.rotate(angle); context.fillStyle=barrelColor; context.fillRect(0,-genBarrelWidth/2,genBarrelLength,genBarrelWidth); context.restore(); if (level > 1) { context.fillStyle="#FFD700"; const indSize=size*0.05; const spacing=indSize*2; const totW=(level-1)*spacing; const stX=-(totW/2)+(spacing/2); const indY=-(baseRadius+spacing); for(let i=0;i<level-1;i++){ context.beginPath(); const indX=stX+(i*spacing); context.arc(indX,indY,indSize,0,Math.PI*2); context.fill(); } } console.warn(`Using fallback drawing for tower type: ${typeInfo.id}, Level: ${level}`); } context.restore(); }

    // --- MODIFIED generateBackgroundDetails Function ---
    function generateBackgroundDetails() {
        gameState.backgroundDetails = []; // Keep for non-grass/flower details if any
        gameState.trees = [];             // Reset trees array
        gameState.rockPiles = [];         // Reset rock piles array

        const baseRockPileDensity = 0.08;
        const increasedRockPileDensity = 0.12; // Higher density for right side
        const fixedFormationTiles = [ // Tiles for the fixed rock formation
            { r: 9, c: 18 },
            { r: 10, c: 17 },
            { r: 10, c: 18 },
            { r: 11, c: 18 } // Added one more for a small cluster
        ];
        let formationTilesGenerated = new Set(); // Track generated formation parts

        // --- Helper to check if a tile is adjacent to path ---
        const isAdjacentToPath = (row, col) => {
            const neighbors = [
                { r: row - 1, c: col },
                { r: row + 1, c: col },
                { r: row, c: col - 1 },
                { r: row, c: col + 1 },
            ];
            for (const neighbor of neighbors) {
                // Check bounds implicitly via isTileOnPath if it handles out-of-bounds
                if (isTileOnPath(neighbor.r, neighbor.c)) {
                    return true;
                }
            }
            return false;
        };

        // --- Helper to generate a rock pile ---
        const createRockPile = (row, col) => {
             if (isTileOnPath(row, col)) return null; // Don't create on path

             const { x: tileX, y: tileY } = getPixelCoordsFromTile(row, col, false);
             const pileCenterX = tileX + config.TILE_SIZE / 2 + (Math.random() - 0.5) * config.TILE_SIZE * 0.4;
             const pileCenterY = tileY + config.TILE_SIZE / 2 + (Math.random() - 0.5) * config.TILE_SIZE * 0.4;
             const numRocksInPile = 4 + Math.floor(Math.random() * 5); // Slightly more rocks per pile
             const pileRadius = config.TILE_SIZE * (0.2 + Math.random() * 0.15); // Slightly larger piles
             const individualRocks = [];
             for (let i = 0; i < numRocksInPile; i++) {
                 const angle = Math.random() * Math.PI * 2;
                 const distance = Math.random() * pileRadius;
                 const rockX = pileCenterX + Math.cos(angle) * distance;
                 const rockY = pileCenterY + Math.sin(angle) * distance;
                 const rockSize = config.TILE_SIZE * (0.08 + Math.random() * 0.09); // Slightly varied rock sizes
                 const rockColorVal = 90 + Math.random() * 60; // Adjusted color range
                 individualRocks.push({ x: rockX - rockSize / 2, y: rockY - rockSize / 2, size: rockSize, color: `rgb(${rockColorVal}, ${rockColorVal}, ${rockColorVal})` });
             }
             return { r: row, c: col, rocks: individualRocks };
        };

        // --- Generate Background Details ---
        for (let r = 0; r < config.MAP_HEIGHT_TILES; r++) {
            for (let c = 0; c < config.MAP_WIDTH_TILES; c++) {
                // Skip path tiles
                if (isTileOnPath(r, c)) continue;

                let tileHandled = false;

                // Check for Fixed Rock Formation Tiles
                const isFormationTile = fixedFormationTiles.some(tile => tile.r === r && tile.c === c);
                if (isFormationTile) {
                    const formationKey = `${r},${c}`;
                    if (!formationTilesGenerated.has(formationKey)) {
                        const rockPile = createRockPile(r, c);
                        if (rockPile) {
                             gameState.rockPiles.push(rockPile);
                             formationTilesGenerated.add(formationKey);
                        }
                        tileHandled = true; // Mark as handled even if pile wasn't created (e.g., if on path, though we check)
                    }
                }

                // Rock Pile Logic (Random Generation)
                if (!tileHandled) {
                    const density = (c >= config.MAP_WIDTH_TILES / 2) ? increasedRockPileDensity : baseRockPileDensity;
                    if (Math.random() < density) {
                         const rockPile = createRockPile(r, c);
                         if (rockPile) {
                              gameState.rockPiles.push(rockPile);
                              tileHandled = true;
                         }
                    }
                }

                // Other Background Detail Logic (Flowers Only - COMMENTED OUT)
                /*
                if (!tileHandled && Math.random() < config.BACKGROUND_DETAIL_DENSITY) {
                     const { x, y } = getPixelCoordsFromTile(r, c, false);
                     let detail = { r, c, x, y };
                     // Removed the 'grass' (detailType < 0.5) condition
                     // Always make flowers if a detail is generated here
                     detail.type = 'flower';
                     detail.color = config.FLOWER_COLORS[Math.floor(Math.random() * config.FLOWER_COLORS.length)];
                     detail.petalSize = config.TILE_SIZE * (0.05 + Math.random() * 0.05);
                     detail.centerSize = config.TILE_SIZE * (0.04 + Math.random() * 0.03);
                     detail.centerX = x + config.TILE_SIZE / 2 + (Math.random() - 0.5) * config.TILE_SIZE * 0.2;
                     detail.centerY = y + config.TILE_SIZE / 2 + (Math.random() - 0.5) * config.TILE_SIZE * 0.2;
                     detail.numPetals = Math.floor(4 + Math.random() * 3);
                     gameState.backgroundDetails.push(detail);
                }
                */
            }
        }


        // --- Generate Trees ONLY on Border Tiles (Not on Path AND Not Adjacent to Path) ---
        for (let r = 0; r < config.MAP_HEIGHT_TILES; r++) {
            for (let c = 0; c < config.MAP_WIDTH_TILES; c++) {
                // Check if it's a border tile
                const isBorder = r === 0 || r === config.MAP_HEIGHT_TILES - 1 || c === 0 || c === config.MAP_WIDTH_TILES - 1;

                // NEW Condition: Check if adjacent to path
                const isNearPath = isAdjacentToPath(r, c);

                // Add tree ONLY if it's a border tile, NOT on the path, AND NOT adjacent to the path
                if (isBorder && !isTileOnPath(r, c) && !isNearPath) {
                    const { x, y } = getPixelCoordsFromTile(r, c, true); // Center position for drawing logic
                    const baseSize = config.TILE_SIZE * (0.8 + Math.random() * 0.6); // Keep random size
                    const topSize = baseSize * (0.6 + Math.random() * 0.3);
                    gameState.trees.push({
                        r, c, // Store tile coords if needed later
                        x, y, // Pixel coords for drawing
                        baseHeight: baseSize * 0.4,
                        baseWidth: baseSize * 0.25,
                        foliageRadius: topSize / 2,
                        baseColor: "#8B4513", // Consistent base color
                        foliageColor: `rgb(${50 + Math.random()*30}, ${100 + Math.random()*55}, ${50 + Math.random()*30})` // Random green foliage
                    });
                }
            }
        }
    }
    // --- END MODIFIED Function ---

    function generatePathDecorations() { gameState.pathDecorations = []; const pathStoneColor = '#909090'; const pathStoneSize = config.TILE_SIZE * 0.15; const pathJitterAmount = config.TILE_SIZE * 0.05; const baseStonePositions = [ { rx: 0.25, ry: 0.25 }, { rx: 0.75, ry: 0.25 }, { rx: 0.25, ry: 0.50 }, { rx: 0.75, ry: 0.50 }, { rx: 0.25, ry: 0.75 }, { rx: 0.75, ry: 0.75 }, ]; for (let r = 0; r < config.MAP_HEIGHT_TILES; r++) { for (let c = 0; c < config.MAP_WIDTH_TILES; c++) { if (isTileOnPath(r, c) && !isTileInTunnel(r, c)) { const { x: tileX, y: tileY } = getPixelCoordsFromTile(r, c, false); const decorationsForTile = []; baseStonePositions.forEach(pos => { const baseStoneX = tileX + config.TILE_SIZE * pos.rx; const baseStoneY = tileY + config.TILE_SIZE * pos.ry; const jitterX = (Math.random() - 0.5) * 2 * pathJitterAmount; const jitterY = (Math.random() - 0.5) * 2 * pathJitterAmount; const stoneDrawX = baseStoneX + jitterX - pathStoneSize / 2; const stoneDrawY = baseStoneY + jitterY - pathStoneSize / 2; decorationsForTile.push({ x: stoneDrawX, y: stoneDrawY, size: pathStoneSize, color: pathStoneColor }); }); gameState.pathDecorations.push({ r, c, decorations: decorationsForTile }); } } } }
    function drawMap() { ctx.fillStyle = config.BG_COLOR; ctx.fillRect(0, 0, canvas.width, canvas.height); gameState.rockPiles.forEach(pile => { pile.rocks.forEach(rock => { ctx.fillStyle = rock.color; ctx.fillRect(rock.x, rock.y, rock.size, rock.size); }); }); gameState.trees.forEach(tree => { ctx.fillStyle = tree.baseColor; const trunkX = tree.x - tree.baseWidth / 2; const trunkY = tree.y - tree.baseHeight / 2; ctx.fillRect(trunkX, trunkY, tree.baseWidth, tree.baseHeight); ctx.fillStyle = tree.foliageColor; ctx.beginPath(); const foliageCenterX = tree.x; const foliageCenterY = trunkY - tree.foliageRadius * 0.3; ctx.arc(foliageCenterX, foliageCenterY, tree.foliageRadius, 0, Math.PI * 2); ctx.fill(); }); gameState.backgroundDetails.forEach(detail => { /* Removed 'grass' drawing */ if (detail.type === 'flower') { ctx.fillStyle = detail.color; for (let i = 0; i < detail.numPetals; i++) { const angle = (i / detail.numPetals) * Math.PI * 2; const petalX = detail.centerX + Math.cos(angle) * detail.petalSize * 1.5; const petalY = detail.centerY + Math.sin(angle) * detail.petalSize * 1.5; ctx.beginPath(); ctx.arc(petalX, petalY, detail.petalSize, 0, Math.PI * 2); ctx.fill(); } ctx.fillStyle = "#DAA520"; ctx.beginPath(); ctx.arc(detail.centerX, detail.centerY, detail.centerSize, 0, Math.PI * 2); ctx.fill(); } }); ctx.lineWidth = 1; for (let r = 0; r < config.MAP_HEIGHT_TILES; r++) { for (let c = 0; c < config.MAP_WIDTH_TILES; c++) { if (isTileOnPath(r, c)) { const { x, y } = getPixelCoordsFromTile(r, c, false); const isInTunnel = isTileInTunnel(r, c); ctx.fillStyle = config.PATH_COLOR; ctx.fillRect(x, y, config.TILE_SIZE, config.TILE_SIZE); if (!isInTunnel) { ctx.strokeStyle = config.PATH_BORDER_COLOR; ctx.strokeRect(x, y, config.TILE_SIZE, config.TILE_SIZE); } } } } gameState.pathDecorations.forEach(pathTile => { pathTile.decorations.forEach(deco => { ctx.fillStyle = deco.color; ctx.fillRect(deco.x, deco.y, deco.size, deco.size); }); }); const tunnelRow = 7; const tunnelStartCol = 8; const tunnelEndCol = 12; const tunnelStartX = tunnelStartCol * config.TILE_SIZE; const tunnelEndX = (tunnelEndCol + 1) * config.TILE_SIZE; const tunnelWidth = tunnelEndX - tunnelStartX; const tunnelYTop = tunnelRow * config.TILE_SIZE; const tunnelYBottom = (tunnelRow + 1) * config.TILE_SIZE; const wallHeight = config.TILE_SIZE * 0.4; const wallColor = '#708090'; const wallHighlight = '#A0AEC0'; ctx.fillStyle = 'rgba(0, 0, 0, 0.25)'; ctx.fillRect(tunnelStartX, tunnelYTop, tunnelWidth, config.TILE_SIZE); ctx.fillStyle = wallColor; ctx.fillRect(tunnelStartX, tunnelYTop - wallHeight, tunnelWidth, wallHeight); ctx.fillStyle = wallHighlight; ctx.fillRect(tunnelStartX, tunnelYTop - wallHeight, tunnelWidth, 2); ctx.fillStyle = wallColor; ctx.fillRect(tunnelStartX, tunnelYBottom, tunnelWidth, wallHeight); ctx.fillStyle = wallHighlight; ctx.fillRect(tunnelStartX, tunnelYBottom, tunnelWidth, 2); }
    function drawEnemies() { gameState.enemies.forEach(enemy => enemy.draw(ctx)); }
    function drawTowers() { gameState.towers.forEach(tower => tower.draw(ctx)); }
    function spawnFireParticles(x, y, count = 10, duration = 300) { const now = performance.now(); const baseSpeed = config.TILE_SIZE * 0.05; const colors = ["#FFA500", "#FF6347", "#FFD700", "#FF4500", "#FF8C00"]; for (let i = 0; i < count; i++) { const angle = Math.random() * Math.PI * 2; const speed = baseSpeed * (0.5 + Math.random() * 0.9); const particleLife = duration * (0.7 + Math.random() * 0.6); gameState.particles.push({ id: `particle-${Math.random().toString(36).substring(2, 9)}`, x: x + (Math.random() - 0.5) * 5, y: y + (Math.random() - 0.5) * 5, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, size: Math.max(1, config.TILE_SIZE * (0.03 + Math.random() * 0.08)), color: colors[Math.floor(Math.random() * colors.length)], startTime: now, duration: particleLife, }); } }
    function spawnFireTrail(startX, startY, endX, endY, count = 15, duration = 200) { const now = performance.now(); const dx = endX - startX; const dy = endY - startY; const dist = Math.hypot(dx, dy); if (dist < 1) return; const nx = dx / dist; const ny = dy / dist; const px = -ny; const py = nx; const baseSpeed = config.TILE_SIZE * 0.02; const spreadAmount = config.TILE_SIZE * 0.1; const colors = ["#FFA500", "#FF6347", "#FFD700", "#FF4500"]; for (let i = 0; i < count; i++) { const trailDist = Math.random() * dist; const spawnX = startX + nx * trailDist + (Math.random() - 0.5) * spreadAmount * 0.5; const spawnY = startY + ny * trailDist + (Math.random() - 0.5) * spreadAmount * 0.5; const perpVel = (Math.random() - 0.5) * baseSpeed * 2; const forwardVel = baseSpeed * (0.1 + Math.random() * 0.3); const particleLife = duration * (0.5 + Math.random() * 0.5); gameState.particles.push({ id: `particle-trail-${Math.random().toString(36).substring(2, 9)}`, x: spawnX, y: spawnY, vx: px * perpVel + nx * forwardVel, vy: py * perpVel + ny * forwardVel, size: Math.max(1, config.TILE_SIZE * (0.02 + Math.random() * 0.05)), color: colors[Math.floor(Math.random() * colors.length)], startTime: now, duration: particleLife, }); } }
    function createHitEffect(startX, startY, endX, endY, color = '#FFFFFF', tower = null, duration = 150) { const effectId = Math.random().toString(36).substring(2, 15); const now = performance.now(); let lineClass = 'hit-effect-line'; let effectDuration = duration; if (tower && tower.typeId === 'CANNON') { if (tower.level === 4 && tower.upgradePath === 'dragon') { spawnFireTrail(startX, startY, endX, endY, 15, duration * 1.5); spawnFireParticles(endX, endY, 8, duration * 2.0); return; } else if (tower.level === 4 && tower.upgradePath === 'double') { gameState.hitVisuals.push({ id: `hit-${effectId}-double`, type: 'cannonball', x: endX, y: endY, size: config.TILE_SIZE * 0.20, color: color || '#503010', startTime: now, duration: duration * 1.2 }); return; } else { gameState.hitVisuals.push({ id: `hit-${effectId}`, type: 'cannonball', x: endX, y: endY, size: config.TILE_SIZE * 0.15, color: color || '#202020', startTime: now, duration: duration }); return; } } else if (tower && tower.typeId === 'GATLING') { lineClass = 'hit-effect-line gatling-tracer'; effectDuration = 75; } const dx = endX - startX; const dy = endY - startY; const length = Math.hypot(dx, dy); if (length < 1) return; const angle = Math.atan2(dy, dx); const { scale, offsetX, offsetY } = getVisualCanvasProperties(); const visualStartX = startX * scale + offsetX; const visualStartY = startY * scale + offsetY; const visualLength = length * scale; const line = document.createElement('div'); line.className = lineClass; line.id = `hit-${effectId}`; line.style.left = `${visualStartX}px`; line.style.top = `${visualStartY}px`; line.style.width = `${visualLength}px`; line.style.backgroundColor = color; line.style.transform = `rotate(${angle}rad)`; canvasContainer.appendChild(line); requestAnimationFrame(() => { line.style.opacity = '1'; }); setTimeout(() => { line.style.opacity = '0'; setTimeout(() => { if (line.parentNode) { line.remove(); } }, 100); }, effectDuration); }
    function drawHitVisuals() { const now = performance.now(); gameState.hitVisuals.forEach(hv => { const elapsed = now - hv.startTime; const lifeRatio = Math.max(0, 1.0 - (elapsed / hv.duration)); if (lifeRatio <= 0) return; ctx.save(); ctx.globalAlpha = lifeRatio; if (hv.type === 'cannonball') { ctx.fillStyle = hv.color; ctx.beginPath(); ctx.arc(hv.x, hv.y, hv.size * (0.5 + lifeRatio * 0.5), 0, Math.PI * 2); ctx.fill(); } ctx.restore(); }); }
    function drawParticles() { const now = performance.now(); gameState.particles.forEach(p => { const elapsed = now - p.startTime; const lifeRatio = Math.max(0, 1.0 - (elapsed / p.duration)); if (lifeRatio <= 0) return; ctx.save(); ctx.globalAlpha = lifeRatio * 0.9; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size * (0.5 + lifeRatio * 0.5), 0, Math.PI * 2); ctx.fill(); ctx.restore(); }); }

    // MODIFIED: draw function now includes drawing the wave number
    function updateUI() {
        if (goldCounterEl) goldCounterEl.textContent = gameState.gold;
        if (livesCounterEl) livesCounterEl.textContent = gameState.lives;
        // Wave number is now drawn on canvas

        if (!gameState.gameHasStarted && gameState.wave === 0) {
            if (towerSelectionPanelContent) {
                towerSelectionPanelContent.querySelectorAll('.tower-item').forEach(item => {
                    const typeId = item.dataset.towerType;
                    if (typeId && TOWER_TYPES[typeId]) {
                        const baseCost = typeof TOWER_TYPES[typeId].baseCost === 'function' ? TOWER_TYPES[typeId].baseCost() : TOWER_TYPES[typeId].baseCost;
                        const canAfford = config.INITIAL_GOLD >= baseCost;
                        item.classList.toggle('disabled', !canAfford);
                    }
                });
            }
        } else {
            if (towerSelectionPanelContent) {
                towerSelectionPanelContent.querySelectorAll('.tower-item').forEach(item => {
                    const typeId=item.dataset.towerType;
                    if(typeId && TOWER_TYPES[typeId]){
                        const baseCost=typeof TOWER_TYPES[typeId].baseCost==='function'?TOWER_TYPES[typeId].baseCost():TOWER_TYPES[typeId].baseCost;
                        const canAfford=gameState.gold >= baseCost;
                        item.classList.toggle('disabled', !canAfford);
                    }
                });
            }
            if (gameState.selectedTower) { updateTowerInfoPanel(gameState.selectedTower); }
            else { updateTowerInfoPanel(null, gameState.placingTowerType); }
        }
    }

    function renderTowerSelection() { if (!towerSelectionPanelContent) { console.error("Cannot render tower selection: Panel content element not found."); return; } towerSelectionPanelContent.innerHTML = ''; Object.values(TOWER_TYPES).forEach(type => { const item = document.createElement('div'); item.classList.add('tower-item'); item.dataset.towerType = type.id; const baseCostVal = typeof type.baseCost==='function'?type.baseCost():type.baseCost; item.setAttribute('data-tooltip', `${type.name} - Cost: ${baseCostVal}💰`); const previewIconContainer = document.createElement('div'); previewIconContainer.classList.add('tower-preview-icon'); item.appendChild(previewIconContainer); const previewCanvas = document.createElement('canvas'); const previewSize = 38; previewCanvas.width = previewSize; previewCanvas.height = previewSize; previewIconContainer.appendChild(previewCanvas); const previewCtx = previewCanvas.getContext('2d'); previewCtx.imageSmoothingEnabled = false; const initialAngle = type.initialAngle ?? -Math.PI / 2; drawTowerOnCanvas(previewCtx, type, previewSize / 2, previewSize / 2, 1, initialAngle, null); const nameEl = document.createElement('div'); nameEl.classList.add('tower-name'); nameEl.textContent=type.name; item.appendChild(nameEl); const costEl = document.createElement('div'); costEl.classList.add('tower-cost'); costEl.textContent=baseCostVal; item.appendChild(costEl); item.addEventListener('click', ()=>handleTowerSelection(type.id)); item.addEventListener('mouseenter', (e)=>{ if(!gameState.selectedTower){ updateTowerInfoPanel(null, type.id); } }); item.addEventListener('mouseleave', ()=>{ if(!gameState.selectedTower){ updateTowerInfoPanel(null); } else { updateTowerInfoPanel(gameState.selectedTower); } }); towerSelectionPanelContent.appendChild(item); }); }
    function updateTowerInfoPanel(tower, previewTypeId = null) { if (!towerInfoContent || !upgradeOptionsContainer || !towerInfoButtonsContainer || !sellButton || !targetingDropdown) { console.error("Cannot update tower info panel: One or more child elements not found."); return; } upgradeOptionsContainer.innerHTML = ''; towerInfoButtonsContainer.style.display = 'none'; sellButton.style.display = 'none'; targetingDropdown.style.display = 'none'; if (tower) { const stats = tower.stats; const typeInfo = tower.typeInfo; const rangeTiles = (stats.range / config.TILE_SIZE).toFixed(1); let towerDisplayName = tower.getName(); let description = typeInfo.description; if (tower.level === 4) { let pathInfo; if (tower.upgradePath && (tower.typeId === 'CANNON' || tower.typeId === 'CROSSBOW')) { pathInfo = typeInfo[`level4_${tower.upgradePath}`]; } else if (typeInfo.level4 && (tower.typeId === 'LASER' || tower.typeId === 'GATLING')) { pathInfo = typeInfo.level4; } if (pathInfo && pathInfo.description) { description = pathInfo.description; } } let infoHtml = `<p><span class="info-label">Type:</span> <span style="color:${typeInfo.color || '#FFFFFF'};">${towerDisplayName}</span></p> <p><span class="info-label">Level:</span> <span class="stat-value">${tower.level} / ${stats.maxLevel}</span></p> <p><span class="info-label">Damage:</span> <span class="stat-value">${stats.damage.toFixed(1)}</span><span style="font-size:0.8em;">${typeInfo.isBeam ? '/sec' : (typeInfo.firesInFixedDirections ? '/shot/dir' : '')}</span></p> <p><span class="info-label">Range:</span> <span class="stat-value">${rangeTiles}</span> tiles</p> <p><span class="info-label">Fire Rate:</span> <span class="stat-value">${stats.fireRate.toFixed(1)}</span>/sec</p>`; if (!typeInfo.firesInFixedDirections) { infoHtml += `<p><span class="info-label">Targeting:</span> <span id="current-targeting">${tower.targetingMode}</span></p>`; targetingDropdown.style.display = 'block'; targetingDropdown.value = tower.targetingMode; } infoHtml += `<p><span class="info-label">Damage Dealt:</span> <span class="stat-value">${Math.floor(tower.totalDamageDealt)}</span></p> <p><span class="info-label">Investment:</span> <span class="stat-value">${tower.investment}💰</span></p> ${stats.isSplashDamage ? `<p><span class="info-label">Splash:</span> <span class="stat-value">${(stats.splashRadius / config.TILE_SIZE).toFixed(1)}</span> tiles, <span class="stat-value">${stats.maxSplashTargets}</span> targets</p>` : ''} ${stats.appliesSlow ? `<p><span class="info-label">Slow:</span> <span class="stat-value">${(stats.slowAmount * 100).toFixed(0)}%</span> for <span class="stat-value">${(stats.slowDuration / 1000).toFixed(1)}</span>s</p>` : ''} ${stats.splashSlow ? `<p><span class="info-label">Splash Slow:</span> <span class="stat-value">${(stats.slowAmount * stats.splashSlowMultiplier * 100).toFixed(0)}%</span> in <span class="stat-value">${(stats.splashSlowRadius / config.TILE_SIZE).toFixed(1)}</span> tile radius</p>` : ''} <p style="margin-top: 5px; font-style: italic; font-size:9px;">${description}</p>`; towerInfoContent.innerHTML = infoHtml; if (tower.level < stats.maxLevel) { const upgradeCost = stats.nextUpgradeCost; const canAfford = gameState.gold >= upgradeCost; const upgradesTitle = document.createElement('h4'); upgradesTitle.id = 'upgrades-title'; upgradesTitle.textContent = 'Upgrades'; upgradeOptionsContainer.appendChild(upgradesTitle); if (tower.level === 3 && (tower.typeId === 'CANNON' || tower.typeId === 'CROSSBOW')) { const l4Wrapper = document.createElement('div'); l4Wrapper.classList.add('l4-choice-wrapper'); let paths = []; if (tower.typeId === 'CANNON') paths = ['dragon', 'double']; if (tower.typeId === 'CROSSBOW') paths = ['bigarrows', 'icebow']; paths.forEach(path => { const pathInfo = typeInfo[`level4_${path}`]; if (pathInfo) { const choiceDiv = document.createElement('div'); choiceDiv.classList.add('upgrade-option', 'l4-choice'); if (!canAfford) choiceDiv.classList.add('disabled'); let iconHtml = ''; choiceDiv.innerHTML = `<span class="upgrade-option-title">${iconHtml}${pathInfo.title}</span> <span class="upgrade-option-desc">${pathInfo.description}</span> <span class="upgrade-option-cost">${upgradeCost}💰</span>`; choiceDiv.onclick = () => { if (canAfford) tower.finalizeUpgrade(path); else showMessage("Not enough gold!"); }; l4Wrapper.appendChild(choiceDiv); } }); upgradeOptionsContainer.appendChild(l4Wrapper); } else { const nextLevel = tower.level + 1; const upgradeInfo = typeInfo.upgrades?.[`level${nextLevel}`] ?? typeInfo.level4; const optionDiv = document.createElement('div'); optionDiv.classList.add('upgrade-option'); if (!canAfford) optionDiv.classList.add('disabled'); optionDiv.innerHTML = `<span class="upgrade-option-title">${upgradeInfo?.title || `Upgrade to Level ${nextLevel}`}</span> <span class="upgrade-option-desc">${upgradeInfo?.description || 'Improves tower stats.'}</span> <span class="upgrade-option-cost">${upgradeCost}💰</span>`; optionDiv.onclick = () => { if (canAfford) tower.upgrade(); else showMessage("Not enough gold!"); }; upgradeOptionsContainer.appendChild(optionDiv); } } towerInfoButtonsContainer.style.display = 'flex'; sellButton.style.display = 'block'; sellButton.textContent = `Sell (${stats.sellValue}💰)`; sellButton.disabled = false; } else if (previewTypeId) { const typeInfo = TOWER_TYPES[previewTypeId]; const statsL1 = calculateTowerStats(previewTypeId, 1); const baseCostPreview = typeof typeInfo.baseCost === 'function' ? typeInfo.baseCost() : typeInfo.baseCost; const rangeTilesPreview = (statsL1.range / config.TILE_SIZE).toFixed(1); towerInfoContent.innerHTML = `<p><span class="info-label">Build:</span> <span style="color:${typeInfo.color || '#FFFFFF'};">${typeInfo.name}</span></p> <p><span class="info-label">Cost:</span> <span class="stat-value">${baseCostPreview}💰</span></p> <p><span class="info-label">Damage:</span> <span class="stat-value">${statsL1.damage.toFixed(1)}</span><span style="font-size:0.8em;">${typeInfo.isBeam ? '/sec' : (typeInfo.firesInFixedDirections ? '/shot/dir' : '')}</span></p> <p><span class="info-label">Range:</span> <span class="stat-value">${rangeTilesPreview}</span> tiles</p> <p><span class="info-label">Fire Rate:</span> <span class="stat-value">${statsL1.fireRate.toFixed(1)}</span>/sec</p> ${statsL1.appliesSlow ? `<p><span class="info-label">Slow:</span> <span class="stat-value">${(statsL1.slowAmount * 100).toFixed(0)}%</span> for <span class="stat-value">${(statsL1.slowDuration / 1000).toFixed(1)}</span>s</p>` : ''} <p style="margin-top: 5px; font-style: italic; font-size:9px;">${typeInfo.description}</p>`; towerInfoButtonsContainer.style.display = 'none'; } else { towerInfoContent.innerHTML = 'Select a tower...'; towerInfoButtonsContainer.style.display = 'none'; } }
    function placeTower(row, col) { if (!gameState.placingTowerType) return; const towerType=TOWER_TYPES[gameState.placingTowerType]; if (!towerType) return; const baseCost=typeof towerType.baseCost==='function'?towerType.baseCost():towerType.baseCost; if (isTileValidForPlacement(row, col) && gameState.gold >= baseCost) { gameState.gold-=baseCost; const newTower=new Tower(gameState.placingTowerType,row,col); gameState.towers.push(newTower); gameState.occupiedTiles.add(`${row},${col}`); gameState.towerDamageTracker.set(newTower.id,0); gameState.totalTowerInvestment.set(newTower.id, newTower.investment); selectTowerForPlacement(null); selectTower(newTower); updateUI(); } else if (gameState.gold < baseCost) { showMessage("Not enough gold!"); selectTowerForPlacement(null); } else { showMessage("Cannot place tower here!"); } }
    function selectTower(tower) { if (gameState.placingTowerType) { selectTowerForPlacement(null); } gameState.selectedTower = tower; updateSelectionHighlight(tower); updateTowerInfoPanel(tower); if (tower) { const { x, y } = getPixelCoordsFromTile(tower.row, tower.col, true); updateRangePreview(x, y, tower.stats.range, true); canvas.classList.remove('cursor-placement', 'cursor-invalid', 'cursor-default'); canvas.classList.add('cursor-pointer'); } else { hideRangePreview(); canvas.classList.remove('cursor-placement', 'cursor-invalid', 'cursor-pointer'); canvas.classList.add('cursor-default'); } }
    function selectTowerForPlacement(typeId) { if (gameState.selectedTower) { selectTower(null); } gameState.placingTowerType = typeId; if (towerSelectionPanelContent) { towerSelectionPanelContent.querySelectorAll('.tower-item').forEach(item => { item.classList.remove('selected-for-placement'); if (item.dataset.towerType === typeId) { item.classList.add('selected-for-placement'); } }); } if (typeId) { try { handleMouseMove({ clientX: gameState.mousePos.x, clientY: gameState.mousePos.y }); } catch(e) { /* ignore */ } updateTowerInfoPanel(null, typeId); } else { hideRangePreview(); updatePlacementPreview(false); canvas.classList.remove('cursor-placement', 'cursor-invalid', 'cursor-pointer'); canvas.classList.add('cursor-default'); updateTowerInfoPanel(null); } }
    function handleTowerSelection(typeId) { const towerType = TOWER_TYPES[typeId]; if (!towerType) return; const baseCost = typeof towerType.baseCost === 'function' ? towerType.baseCost() : towerType.baseCost; if (gameState.gold >= baseCost) { if (gameState.placingTowerType === typeId) { selectTowerForPlacement(null); } else { selectTowerForPlacement(typeId); } } else { showMessage("Not enough gold to build this tower!"); selectTowerForPlacement(null); } }
    function sellSelectedTower() { if (gameState.selectedTower) { const sellValue = gameState.selectedTower.stats.sellValue; const towerIdToRemove = gameState.selectedTower.id; const success = gameState.selectedTower.sell(); if (success) { gameState.towers = gameState.towers.filter(t => t.id !== towerIdToRemove); selectTower(null); updateTowerInfoPanel(null); showMessage(`Tower sold for ${sellValue}💰`); } } }
    function changeTargetingMode() { if (gameState.selectedTower && !gameState.selectedTower.typeInfo.firesInFixedDirections) { gameState.selectedTower.targetingMode = targetingDropdown.value; updateTowerInfoPanel(gameState.selectedTower); } }
    function gameLoop(timestamp) { if (!gameState.isRunning) return; const currentTime = performance.now(); const rawDeltaTime = (currentTime - gameState.lastFrameTime) / 1000; gameState.deltaTime = Math.min(rawDeltaTime, 0.1); gameState.lastFrameTime = currentTime; if (!gameState.isPaused) { update(gameState.deltaTime); } draw(); gameState.gameLoopRequestId = requestAnimationFrame(gameLoop); }
    function update(deltaTime) { if (gameState.isPaused || !gameState.isRunning) return; const now = performance.now(); const dtMs = deltaTime * 1000 * gameState.gameSpeed; for (let i = gameState.particles.length - 1; i >= 0; i--) { const p = gameState.particles[i]; p.x += p.vx * dtMs * 0.05; p.y += p.vy * dtMs * 0.05; if (now > p.startTime + p.duration) { gameState.particles.splice(i, 1); } } for (let i = gameState.hitVisuals.length - 1; i >= 0; i--) { const hv = gameState.hitVisuals[i]; if (now > hv.startTime + hv.duration) { gameState.hitVisuals.splice(i, 1); } } if (gameState.waveInProgress && gameState.spawnQueue.length > 0 && Date.now() >= gameState.nextSpawnTime) { spawnEnemy(); } gameState.enemies.forEach(enemy => enemy.update(deltaTime)); gameState.towers.forEach(tower => tower.update(deltaTime)); const livingEnemies = gameState.enemies.filter(enemy => enemy.isAlive); if (livingEnemies.length !== gameState.enemies.length) { gameState.enemies = livingEnemies; } if (gameState.waveInProgress && gameState.enemies.length === 0 && gameState.spawnQueue.length === 0) { endWave(); } }

    function draw() {
        if (!gameState.isRunning) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawMap();
        drawTowers();
        drawEnemies();
        drawHitVisuals();
        drawParticles();

        // Draw Wave Number on Canvas
        if (gameState.wave > 0 || gameState.gameHasStarted) { // Only draw if game has started/wave > 0
            ctx.save();
            const fontSize = Math.max(12, Math.min(18, config.TILE_SIZE * 0.4)); // Scale size slightly with tile size
            ctx.font = `bold ${fontSize}px 'Press Start 2P', cursive`;
            ctx.fillStyle = "#c53030"; // Darker Red color
            ctx.strokeStyle = "rgba(0,0,0,0.6)"; // Black outline for visibility
            ctx.lineWidth = 2;
            ctx.textAlign = "left";
            ctx.textBaseline = "top";
            const waveText = gameState.wave.toString();
            const xPos = 8; // Padding from left
            const yPos = 5; // Padding from top
            ctx.strokeText(waveText, xPos, yPos); // Draw outline first
            ctx.fillText(waveText, xPos, yPos);   // Draw red fill
            ctx.restore();
        }
    }
    // MODIFIED: Removed toggle button logic from initializeGame
    function initializeGame() { console.log("Initializing game..."); resetGameState(); setupCanvasSize(); definePath(); generatePathDecorations(); generateBackgroundDetails(); renderTowerSelection(); updateUI(); gameState.isRunning = true; gameState.isPaused = false; gameState.gameHasStarted = true; pauseButton.innerHTML = '||'; pauseButton.classList.remove('paused'); pauseButton.disabled = false; speedButton.disabled = false; speedButton.textContent = `${gameState.gameSpeed}x`; startWaveButton.innerHTML = '▶'; startWaveButton.disabled = false; startWaveButton.classList.remove('auto-start-on'); playAgainButton.style.display = 'none'; if (gameState.gameLoopRequestId) { cancelAnimationFrame(gameState.gameLoopRequestId); } gameState.lastFrameTime = performance.now(); gameState.gameLoopRequestId = requestAnimationFrame(gameLoop); console.log("Game Initialized and Started"); }

    // MODIFIED: Removed isBuildPanelOpen reset
    function resetGameState() {
        console.log("Resetting game state...");
        if (gameState.gameLoopRequestId) { cancelAnimationFrame(gameState.gameLoopRequestId); gameState.gameLoopRequestId = null; }
        if (gameState.autoStartTimeoutId) { clearTimeout(gameState.autoStartTimeoutId); gameState.autoStartTimeoutId = null; }
        gameState.hitVisuals = []; gameState.particles = []; document.querySelectorAll('.hit-effect-line').forEach(el => el.remove());
        gameState.gold=config.INITIAL_GOLD; gameState.lives=config.INITIAL_LIVES; gameState.wave=0; // Set game state variables
        gameState.enemies=[]; gameState.towers=[]; gameState.selectedTower=null; gameState.placingTowerType=null;
        gameState.isPaused=true; gameState.isRunning=false; gameState.gameHasStarted=false; gameState.waveInProgress=false;
        gameState.autoStartEnabled=false; gameState.gameSpeed=1; gameState.spawnQueue=[];
        gameState.enemiesThisWave=0; gameState.defeatedThisWave=0; gameState.reachedEndThisWave=0;
        gameState.towerDamageTracker.clear(); gameState.totalTowerInvestment.clear();
        gameState.path=[]; gameState.pathTiles.clear(); gameState.occupiedTiles.clear();
        gameState.lastFrameTime=0; gameState.deltaTime=0; if(gameState.messageTimeout)clearTimeout(gameState.messageTimeout); messageBox.style.display='none';
        hideRangePreview(); updateSelectionHighlight(null); updatePlacementPreview(false);
        gameState.nextBossIndex=0; gameState.activeSatellites.clear(); gameState.deadEnemyPositions=[];
        gameState.trees = []; gameState.backgroundDetails = []; gameState.rockPiles = []; gameState.pathDecorations = [];
        startWaveButton.innerHTML = '▶'; startWaveButton.disabled=true; startWaveButton.classList.remove('auto-start-on');
        speedButton.textContent = `${gameState.gameSpeed}x`; speedButton.disabled=true;
        pauseButton.innerHTML = '||'; pauseButton.classList.remove('paused'); pauseButton.disabled=true;
        playAgainButton.style.display = 'none';
        // removed isBuildPanelOpen reset
        setInitialUI(); // Resets gold/lives display
        console.log("Game State Reset Complete");
    }
    function togglePause() { if (!gameState.isRunning) return; gameState.isPaused = !gameState.isPaused; pauseButton.innerHTML = gameState.isPaused ? '▶' : '||'; pauseButton.classList.toggle('paused', gameState.isPaused); if (gameState.isPaused) { if (gameState.autoStartTimeoutId) { clearTimeout(gameState.autoStartTimeoutId); } showMessage("Game Paused", 5000); } else { gameState.lastFrameTime = performance.now(); if (gameState.autoStartTimeoutId && gameState.autoStartEnabled && !gameState.waveInProgress) { gameState.autoStartTimeoutId = setTimeout(() => { if(gameState.isRunning && !gameState.isPaused && !gameState.waveInProgress && gameState.autoStartEnabled) { startWave(); } gameState.autoStartTimeoutId = null; }, config.AUTO_START_DELAY_MS); } showMessage("Game Resumed", 1500); } }
    function cycleGameSpeed() { if (!gameState.isRunning) return; if(gameState.gameSpeed === 1){ gameState.gameSpeed = 2; } else if (gameState.gameSpeed === 2) { gameState.gameSpeed = 4; } else { gameState.gameSpeed = 1; } speedButton.textContent = `${gameState.gameSpeed}x`; }
    function gameOver() { gameState.isRunning=false; gameState.isPaused=true; gameState.gameHasStarted = false; if(gameState.gameLoopRequestId){ cancelAnimationFrame(gameState.gameLoopRequestId); gameState.gameLoopRequestId=null; } if(gameState.autoStartTimeoutId){ clearTimeout(gameState.autoStartTimeoutId); gameState.autoStartTimeoutId=null; } showMessage("Game Over! 😭",10000); playAgainButton.style.display='block'; startWaveButton.innerHTML = '▶'; startWaveButton.disabled=true; startWaveButton.classList.remove('auto-start-on'); pauseButton.innerHTML = '||'; pauseButton.disabled=true; pauseButton.classList.remove('paused'); speedButton.textContent = '1x'; speedButton.disabled=true; console.log("Game Over"); }
    function getWaveEnemies(waveNum) { const enemiesToSpawn = []; const baseEnemyCount = 5; const countMultiplier = 1.3; const normalEnemyCount = Math.floor(baseEnemyCount * Math.pow(countMultiplier, waveNum - 1)); if (waveNum >= 20 && waveNum % 10 === 0) { const bossKeys = Object.keys(BOSS_TYPES); const bossId = bossKeys[gameState.nextBossIndex % bossKeys.length]; enemiesToSpawn.push(bossId); gameState.nextBossIndex++; const accompanyingEnemies = Math.floor(normalEnemyCount / 3) + 5; for (let i = 0; i < accompanyingEnemies; i++) { const enemyTypeRand = Math.random(); let type; if (waveNum < 25 || enemyTypeRand < 0.7) { type = 'BLUE_CIRCLE'; } else { type = 'GREEN_CIRCLE'; } enemiesToSpawn.push(type); } showMessage(`BOSS WAVE! ${BOSS_TYPES[bossId].name} appears!`, 4000); } else { for (let i = 0; i < normalEnemyCount; i++) { const enemyTypeRand = Math.random(); let type; if (waveNum < 5) { if (enemyTypeRand < 0.6) type = 'RED_CIRCLE'; else type = 'BLUE_CIRCLE'; } else if (waveNum < 10) { if (enemyTypeRand < 0.2) type = 'RED_CIRCLE'; else if (enemyTypeRand < 0.7) type = 'BLUE_CIRCLE'; else type = 'GREEN_CIRCLE'; } else if (waveNum < 15) { if (enemyTypeRand < 0.5) type = 'BLUE_CIRCLE'; else if (enemyTypeRand < 0.85) type = 'GREEN_CIRCLE'; else type = 'PINK_CIRCLE'; } else if (waveNum < 20) { if (enemyTypeRand < 0.15) type = 'BLUE_CIRCLE'; else if (enemyTypeRand < 0.5) type = 'GREEN_CIRCLE'; else if (enemyTypeRand < 0.85) type = 'PINK_CIRCLE'; else type = 'PURPLE_CIRCLE'; } else if (waveNum < 28) { if (enemyTypeRand < 0.30) type = 'GREEN_CIRCLE'; else if (enemyTypeRand < 0.65) type = 'PINK_CIRCLE'; else if (enemyTypeRand < 0.9) type = 'PURPLE_CIRCLE'; else type = 'ORANGE_CIRCLE'; } else { if (enemyTypeRand < 0.30) type = 'PINK_CIRCLE'; else if (enemyTypeRand < 0.65) type = 'PURPLE_CIRCLE'; else if (enemyTypeRand < 0.9) type = 'ORANGE_CIRCLE'; else type = 'YELLOW_CIRCLE'; } if (type) { enemiesToSpawn.push(type); } else { console.warn(`Could not determine enemy type for wave ${waveNum}.`); enemiesToSpawn.push('YELLOW_CIRCLE'); } } } return enemiesToSpawn; }
    function startWave() { if (!gameState.isRunning || gameState.waveInProgress) return; if (gameState.autoStartTimeoutId) { clearTimeout(gameState.autoStartTimeoutId); gameState.autoStartTimeoutId = null; } gameState.waveInProgress=true; gameState.wave++; gameState.defeatedThisWave=0; gameState.reachedEndThisWave=0; startWaveButton.innerHTML = '▶'; startWaveButton.classList.toggle('auto-start-on', gameState.autoStartEnabled); const enemyTypesForWave=getWaveEnemies(gameState.wave); gameState.enemiesThisWave=enemyTypesForWave.length; gameState.spawnQueue=[...enemyTypesForWave]; gameState.nextSpawnTime=Date.now(); updateUI(); // Updates gold/lives, wave # is drawn in draw()
    showMessage(`Wave ${gameState.wave} starting!`); }
    function endWave() { gameState.waveInProgress=false; const bonusGold=config.ROUND_BONUS_FIXED; gameState.gold+=bonusGold; showMessage(`Wave ${gameState.wave} complete! +${bonusGold}💰 bonus.`); startWaveButton.innerHTML = '▶'; if(gameState.autoStartEnabled){ startWaveButton.classList.add('auto-start-on'); gameState.autoStartTimeoutId=setTimeout(()=>{ if(gameState.isRunning&&!gameState.isPaused&&!gameState.waveInProgress&&gameState.autoStartEnabled){ startWave(); } gameState.autoStartTimeoutId=null; }, config.AUTO_START_DELAY_MS); } else { startWaveButton.classList.remove('auto-start-on'); } updateUI(); }
    function spawnEnemy() { if (gameState.spawnQueue.length > 0) { const enemyType = gameState.spawnQueue.shift(); const newEnemy = new Enemy(enemyType, gameState.wave); gameState.enemies.push(newEnemy); gameState.nextSpawnTime = Date.now() + (config.ENEMY_SPAWN_INTERVAL_MS / gameState.gameSpeed); } }
    function handleStartWaveClick() { if (!gameState.isRunning || gameState.isPaused) return; if (gameState.waveInProgress) { gameState.autoStartEnabled = !gameState.autoStartEnabled; startWaveButton.classList.toggle('auto-start-on', gameState.autoStartEnabled); showMessage(gameState.autoStartEnabled ? "Auto Start Enabled" : "Auto Start Disabled", 1500); if(!gameState.autoStartEnabled && gameState.autoStartTimeoutId){ clearTimeout(gameState.autoStartTimeoutId); gameState.autoStartTimeoutId = null;} } else { if (gameState.autoStartEnabled) { gameState.autoStartEnabled=false; startWaveButton.classList.remove('auto-start-on'); showMessage("Auto Start Disabled", 1500); if(gameState.autoStartTimeoutId){ clearTimeout(gameState.autoStartTimeoutId); gameState.autoStartTimeoutId = null;} } startWave(); } startWaveButton.innerHTML = '▶'; }

    // MODIFIED: Simplified canvas click logic to allow actions when paused
    function handleCanvasClick(event) {
        // Allow clicks even if paused, only check if game is running
        if (!gameState.isRunning) return;
        // Removed check for event.target === toggleRightPanelButton

        const rect = canvas.getBoundingClientRect();
        const mouseXRelative = event.clientX - rect.left;
        const mouseYRelative = event.clientY - rect.top;
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const canvasX = mouseXRelative * scaleX;
        const canvasY = mouseYRelative * scaleY;
        const { row, col } = getTileCoordsFromPixels(canvasX, canvasY);

        // Check if click is outside the canvas bounds *within the container*
        if (mouseXRelative < 0 || mouseXRelative > rect.width || mouseYRelative < 0 || mouseYRelative > rect.height) {
             // Click was likely on padding or margin outside the visual canvas
             // Maybe deselect? Or ignore. Let's ignore for now.
             // selectTower(null);
             // selectTowerForPlacement(null);
             return;
         }

        // Check if click is outside map grid bounds
        if (row < 0 || row >= config.MAP_HEIGHT_TILES || col < 0 || col >= config.MAP_WIDTH_TILES) {
            selectTower(null);
            selectTowerForPlacement(null);
            return;
        }

        // Handle tower placement or selection
        if (gameState.placingTowerType) {
            placeTower(row, col);
        } else {
            const clickedTower = gameState.towers.find(tower => tower.row === row && tower.col === col);
            if (clickedTower) {
                if (gameState.selectedTower && gameState.selectedTower.id === clickedTower.id) {
                    selectTower(null); // Deselect if clicking the selected tower again
                } else {
                    selectTower(clickedTower);
                }
            } else {
                selectTower(null); // Deselect if clicking empty ground
            }
        }
    }
    function handleMouseMove(event) { if (!gameState.isRunning) return; const rect = canvas.getBoundingClientRect(); const mouseXRelative = event.clientX - rect.left; const mouseYRelative = event.clientY - rect.top; const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height; const canvasX = mouseXRelative * scaleX; const canvasY = mouseYRelative * scaleY; gameState.mousePos = { x: canvasX, y: canvasY }; const { row, col } = getTileCoordsFromPixels(canvasX, canvasY); if (row < 0 || row >= config.MAP_HEIGHT_TILES || col < 0 || col >= config.MAP_WIDTH_TILES) { if (gameState.placingTowerType) { hideRangePreview(); updatePlacementPreview(false); canvas.classList.remove('cursor-placement', 'cursor-default', 'cursor-pointer'); canvas.classList.add('cursor-invalid'); } gameState.mouseTile = { row: -1, col: -1 }; return; } const tileChanged = gameState.mouseTile.row !== row || gameState.mouseTile.col !== col; if (!tileChanged && !gameState.placingTowerType) { return; } gameState.mouseTile = { row, col }; if (gameState.placingTowerType) { const typeInfo = TOWER_TYPES[gameState.placingTowerType]; const baseCost = typeof typeInfo.baseCost === 'function' ? typeInfo.baseCost() : typeInfo.baseCost; const isValid = isTileValidForPlacement(row, col); const canAfford = gameState.gold >= baseCost; const baseRange = typeof typeInfo.baseRange === 'function' ? typeInfo.baseRange() : typeInfo.baseRange; const tilePixelCoords = getPixelCoordsFromTile(row, col, false); const centerPixelCoords = getPixelCoordsFromTile(row, col, true); updateRangePreview(centerPixelCoords.x, centerPixelCoords.y, baseRange, isValid && canAfford); updatePlacementPreview(true, gameState.placingTowerType, tilePixelCoords.x, tilePixelCoords.y); if (isValid && canAfford) { canvas.classList.remove('cursor-invalid', 'cursor-default', 'cursor-pointer'); canvas.classList.add('cursor-placement'); } else { canvas.classList.remove('cursor-placement', 'cursor-default', 'cursor-pointer'); canvas.classList.add('cursor-invalid'); } } else { const hoveredTower = gameState.towers.find(tower => tower.row === row && tower.col === col); if (hoveredTower) { canvas.classList.remove('cursor-placement', 'cursor-invalid', 'cursor-default'); canvas.classList.add('cursor-pointer'); } else { canvas.classList.remove('cursor-placement', 'cursor-invalid', 'cursor-pointer'); canvas.classList.add('cursor-default'); } if (!gameState.selectedTower || gameState.selectedTower.row !== row || gameState.selectedTower.col !== col) { hideRangePreview(); } else { const { x, y } = getPixelCoordsFromTile(gameState.selectedTower.row, gameState.selectedTower.col, true); updateRangePreview(x, y, gameState.selectedTower.stats.range, true); } updatePlacementPreview(false); } }
    function handleMouseLeave() { if (gameState.placingTowerType) { hideRangePreview(); updatePlacementPreview(false); } gameState.mouseTile = { row: -1, col: -1 }; }
    window.addEventListener('resize', () => { if (gameState.isRunning) { if (gameState.selectedTower) { updateSelectionHighlight(gameState.selectedTower); const { x, y } = getPixelCoordsFromTile(gameState.selectedTower.row, gameState.selectedTower.col, true); updateRangePreview(x, y, gameState.selectedTower.stats.range, true); } if (gameState.placingTowerType) { const { row, col } = gameState.mouseTile; if (row !== -1 && col !== -1) { const typeInfo = TOWER_TYPES[gameState.placingTowerType]; const baseCost = typeof typeInfo.baseCost === 'function' ? typeInfo.baseCost() : typeInfo.baseCost; const isValid = isTileValidForPlacement(row, col); const canAfford = gameState.gold >= baseCost; const baseRange = typeof typeInfo.baseRange === 'function' ? typeInfo.baseRange() : typeInfo.baseRange; const tilePixelCoords = getPixelCoordsFromTile(row, col, false); const centerPixelCoords = getPixelCoordsFromTile(row, col, true); updateRangePreview(centerPixelCoords.x, centerPixelCoords.y, baseRange, isValid && canAfford); updatePlacementPreview(true, gameState.placingTowerType, tilePixelCoords.x, tilePixelCoords.y); } else { hideRangePreview(); updatePlacementPreview(false); } } draw(); } });
    // REMOVED: Toggle button event listener

    canvas.addEventListener('click', handleCanvasClick); canvas.addEventListener('mousemove', handleMouseMove); canvas.addEventListener('mouseleave', handleMouseLeave); startWaveButton.addEventListener('click', handleStartWaveClick); pauseButton.addEventListener('click', togglePause); speedButton.addEventListener('click', cycleGameSpeed); sellButton.addEventListener('click', sellSelectedTower); targetingDropdown.addEventListener('change', changeTargetingMode); playAgainButton.addEventListener('click', () => { resetGameState(); initializeGame(); });
    const imageAssetsToLoad = [ "photos/gatling.level1.png", "photos/gatling.level2.png", "photos/gatling.level3.png", "photos/gatling.level4.png", "photos/cannonbottom.level1.png", "photos/cannontop.level1.png", "photos/cannonbottom.level2.png", "photos/cannontop.level2.png", "photos/cannonbottom.level3.png", "photos/cannontop.level3.png", "photos/dragontop.png", "photos/dragonbottom.png", "photos/cannontop.level4.png", "photos/cannonbottom.level4.png", "photos/lazer.level1.png", "photos/lazer.level2.png", "photos/lazer.level3.png", "photos/lazer.level4.png", "photos/crossbowtop.level1.png", "photos/crossbowbottom.level1.png", "photos/crossbowtop.level2.png", "photos/crossbowbottom.level2.png", "photos/crossbowtop.level3.png", "photos/crossbowbottom.level3.png", "photos/crossbowtop.level4.png", "photos/crossbowbottom.level4.png", "photos/icebowtop.png", "photos/icebowbottom.png", ];
    function preloadImages(urls) { const promises = urls.map(url => new Promise((resolve, reject) => { const img = new Image(); img.onload = () => { loadedImages[url] = img; resolve(img); }; img.onerror = () => { console.error(`Failed to load image: ${url}`); loadedImages[url] = null; resolve(null); }; img.src = url; })); return Promise.allSettled(promises); }

    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM Loaded.");
        setInitialUI();
        console.log("Preloading images...");
        preloadImages(imageAssetsToLoad).then((results) => {
            const failed = results.filter(r => r.status === 'rejected');
            if (failed.length > 0) {
                console.warn(`Failed to preload ${failed.length} images.`);
                failed.forEach(f => console.warn(` - Failed: ${f.reason?.message || 'Unknown error'}`));
                showMessage("Error loading some visual assets! Check console.", 5000);
            } else {
                console.log("All required images preloaded successfully.");
            }
            console.log("Preloading complete. Initializing game automatically.");
            initializeGame();
        });
    });

</script>
</body>
</html>